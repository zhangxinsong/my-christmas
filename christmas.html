<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grand Luxury Tree - Christmas Edition</title>
    <style>
        /* ä¿®æ”¹èƒŒæ™¯ä¸ºæ·±è‰²æ¸å˜ï¼Œä¸å†æ˜¯çº¯é»‘ */
        body { 
            margin: 0; 
            overflow: hidden; 
            background: radial-gradient(circle at center, #0f2027 0%, #203a43 50%, #2c5364 100%); 
            background-color: #050d1a; /* Fallback */
            font-family: 'Times New Roman', serif; 
        }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* UI Overlay */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
            display: flex; flex-direction: column; 
            align-items: center;
            padding-top: 40px;
            box-sizing: border-box;
            transition: opacity 0.5s ease;
        }
        
        .ui-hidden {
            opacity: 0 !important;
            pointer-events: none !important;
        }

        /* Loading */
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #050d1a; z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 0.8s ease-out;
        }
        .loader-text {
            color: #d4af37; font-size: 14px; letter-spacing: 4px; margin-top: 20px;
            text-transform: uppercase; font-weight: 100;
        }
        .spinner {
            width: 40px; height: 40px; border: 1px solid rgba(212, 175, 55, 0.2); 
            border-top: 1px solid #d4af37; border-radius: 50%; 
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Progress Bar */
        #progress-container {
            margin-top: 30px;
            width: 300px;
            text-align: center;
            display: none; /* éšè—è¿›åº¦æ¡ */
        }
        #progress-bar {
            width: 100%;
            height: 2px;
            background: rgba(212, 175, 55, 0.2);
            border-radius: 2px;
            overflow: hidden;
            position: relative;
        }
        #progress-bar::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            width: var(--progress, 0%);
            background: #d4af37;
            transition: width 0.3s ease;
        }
        #progress-text {
            color: rgba(212, 175, 55, 0.8);
            font-size: 12px;
            margin-top: 10px;
            letter-spacing: 2px;
        }

        /* Typography - èƒŒæ™¯å±‚æ ‡é¢˜ */
        #background-title {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2;  /* é«˜äºcanvasä½†ä½äºUIå±‚ï¼Œé€šè¿‡é€æ˜åº¦è¥é€ èƒŒæ™¯æ„Ÿ */
            pointer-events: none;
            color: #fceea7;
            font-size: 110px;  /* å¢å¤§å­—ä½“ */
            margin: 0;
            font-weight: 400;
            letter-spacing: 12px;
            text-shadow: 0 0 100px rgba(252, 238, 167, 0.4);
            background: linear-gradient(to bottom, #fff, #eebb66);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            font-family: 'Cinzel', 'Times New Roman', serif;
            opacity: 0.10; /*å¢å¤§é€æ˜åº¦ */
            transition: opacity 0.5s ease;
            white-space: nowrap;
        }

        /* Controls */
        .controls-wrapper {
            position: absolute; 
            top: 30px;          
            right: 30px;        
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 10px;
            z-index: 20;
            transition: opacity 0.5s ease;
        }

        .btn-group {
            display: flex;
            gap: 10px;
        }

        .upload-btn {
            background: rgba(20, 20, 20, 0.6);
            border: 1px solid rgba(212, 175, 55, 0.4);
            color: #d4af37;
            padding: 10px 20px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-size: 10px;
            transition: all 0.4s;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
            width: 170px;
            height: 40px;
            box-sizing: border-box;
            font-family: inherit;
            line-height: 1;
            white-space: nowrap;
        }

        button.upload-btn {
            margin: 0;
            padding: 10px 20px;
        }
        .upload-btn:hover {
            background: #d4af37;
            color: #000;
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
        }

        input[type="file"] { display: none; }

        /* Webcam feedback */
        #webcam-wrapper {
            position: absolute; 
            bottom: 30px;       
            left: 30px;         
            width: 280px;       
            height: 210px;
            border: 1px solid rgba(212, 175, 55, 0.5); 
            box-shadow: 0 0 20px rgba(0,0,0,0.9);
            border-radius: 4px;
            overflow: hidden; 
            opacity: 1;         
            pointer-events: none;
            z-index: 50;
            background: #000;
            transition: opacity 0.5s ease; 
        }
        
        #webcam {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); 
        }

        /* Debug info for gestures */
        #debug-info {
            position: absolute;
            bottom: 5px;
            left: 5px;
            color: rgba(212, 175, 55, 0.8);
            font-size: 10px;
            font-family: monospace;
            background: rgba(0,0,0,0.5);
            padding: 2px 5px;
            pointer-events: none;
        }

        /* FPS Counter */
        #fps-counter {
            position: absolute;
            top: 10px;
            left: 10px;
            color: rgba(212, 175, 55, 0.8);
            font-size: 11px;
            font-family: monospace;
            background: rgba(0,0,0,0.6);
            padding: 5px 10px;
            border-radius: 3px;
            pointer-events: none;
            z-index: 15;
        }

        /* Toast Notification System */
        .toast {
            position: fixed;
            bottom: 80px;
            right: 30px;
            min-width: 280px;
            max-width: 400px;
            background: rgba(20, 20, 20, 0.95);
            border: 1px solid rgba(212, 175, 55, 0.5);
            color: #fff;
            padding: 15px 20px;
            border-radius: 4px;
            z-index: 300;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            animation: slideInRight 0.3s ease;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .toast-success {
            border-color: rgba(76, 175, 80, 0.6);
            background: rgba(27, 94, 32, 0.9);
        }

        .toast-error {
            border-color: rgba(244, 67, 54, 0.6);
            background: rgba(183, 28, 28, 0.9);
        }

        .toast-warning {
            border-color: rgba(255, 193, 7, 0.6);
            background: rgba(255, 111, 0, 0.9);
        }

        .toast-info {
            border-color: rgba(33, 150, 243, 0.6);
            background: rgba(13, 71, 161, 0.9);
        }

        .toast-icon {
            font-size: 20px;
            flex-shrink: 0;
        }

        .toast-message {
            flex: 1;
            font-size: 13px;
            line-height: 1.5;
        }

        @keyframes slideInRight {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .toast-exit {
            animation: slideOutRight 0.3s ease;
        }

        @keyframes slideOutRight {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(400px);
                opacity: 0;
            }
        }

        /* Recording Indicator */
        #recording-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            display: none;
            align-items: center;
            gap: 8px;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 12px;
            border-radius: 4px;
            z-index: 200;
        }

        #recording-indicator.active {
            display: flex;
        }

        .recording-dot {
            width: 10px;
            height: 10px;
            background: #ff0000;
            border-radius: 50%;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.5;
                transform: scale(1.1);
            }
        }

        .recording-time {
            color: #ff0000;
            font-size: 12px;
            font-family: monospace;
            font-weight: bold;
        }

        /* Music Controls */
        #music-controls {
            position: fixed;
            bottom: 30px;
            right: 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            z-index: 100;
            background: rgba(20, 20, 20, 0.85);
            border: 1px solid rgba(212, 175, 55, 0.5);
            border-radius: 8px;
            padding: 10px 12px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        #music-controls:hover {
            background: rgba(20, 20, 20, 0.95);
            box-shadow: 0 0 25px rgba(212, 175, 55, 0.3);
        }

        /* æŒ‰é’®å®¹å™¨ - æ¨ªå‘æ’åˆ— */
        .music-buttons {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .music-btn {
            width: 36px;
            height: 36px;
            background: rgba(212, 175, 55, 0.2);
            border: 1px solid rgba(212, 175, 55, 0.4);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .music-btn:hover {
            background: rgba(212, 175, 55, 0.4);
            border-color: #d4af37;
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.5);
            transform: scale(1.1);
        }

        .music-btn:active {
            transform: scale(0.9);
        }

        .music-icon {
            color: #d4af37;
            line-height: 1;
        }

        /* éŸ³é‡æ§åˆ¶å®¹å™¨ - ç§»é™¤åŸæ¥çš„æ ·å¼ */
        .volume-control {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            width: 100%;
        }

        #volume-slider {
            width: 80px;
            height: 3px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(212, 175, 55, 0.2);
            border-radius: 2px;
            outline: none;
            cursor: pointer;
        }

        #volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 10px;
            height: 10px;
            background: #d4af37;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        #volume-slider::-webkit-slider-thumb:hover {
            background: #ffdd88;
            box-shadow: 0 0 10px rgba(212, 175, 55, 0.8);
            transform: scale(1.3);
        }

        #volume-slider::-moz-range-thumb {
            width: 10px;
            height: 10px;
            background: #d4af37;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        #volume-slider::-moz-range-thumb:hover {
            background: #ffdd88;
            box-shadow: 0 0 10px rgba(212, 175, 55, 0.8);
            transform: scale(1.3);
        }

        .music-status {
            color: rgba(212, 175, 55, 0.7);
            font-size: 8px;
            text-align: center;
            letter-spacing: 1px;
            text-transform: uppercase;
            font-family: monospace;
        }

        /* Autoplay Prompt */
        #autoplay-prompt {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 13, 26, 0.95);
            z-index: 999;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        .prompt-content {
            text-align: center;
            padding: 40px;
            background: rgba(20, 20, 20, 0.9);
            border: 2px solid rgba(212, 175, 55, 0.6);
            border-radius: 12px;
            box-shadow: 0 0 40px rgba(212, 175, 55, 0.3);
            animation: scaleIn 0.5s ease;
        }

        @keyframes scaleIn {
            from {
                transform: scale(0.8);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        .prompt-icon {
            font-size: 72px;
            margin-bottom: 20px;
            animation: bounce 2s infinite;
        }

        @keyframes bounce {
            0%, 100% {
                transform: translateY(0);
            }
            50% {
                transform: translateY(-10px);
            }
        }

        .prompt-text {
            color: #d4af37;
            font-size: 20px;
            letter-spacing: 2px;
            margin-bottom: 30px;
            font-family: 'Cinzel', 'Times New Roman', serif;
        }

        .prompt-btn {
            background: rgba(212, 175, 55, 0.2);
            border: 2px solid #d4af37;
            color: #d4af37;
            padding: 15px 40px;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 3px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.3s ease;
            font-family: inherit;
        }

        .prompt-btn:hover {
            background: #d4af37;
            color: #000;
            box-shadow: 0 0 30px rgba(212, 175, 55, 0.6);
            transform: scale(1.05);
        }

        .prompt-btn:active {
            transform: scale(0.95);
        }

        /* éšè—éŸ³ä¹æ§åˆ¶ */
        #music-controls.ui-hidden {
            opacity: 0;
            pointer-events: none;
        }
    </style>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap');
    </style>

    <!-- html2canvas for screenshot -->
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
            }
        }
    </script>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div class="loader-text">Loading Memories</div>
        <div id="progress-container">
            <div id="progress-bar"></div>
            <div id="progress-text">0 / 0</div>
        </div>
    </div>

    <!-- èƒŒæ™¯å±‚æ ‡é¢˜ -->
    <h1 id="background-title">Merry Christmas</h1>

    <div id="canvas-container"></div>

    <!-- å½•åˆ¶æŒ‡ç¤ºå™¨ -->
    <div id="recording-indicator">
        <div class="recording-dot"></div>
        <div class="recording-time">00:00</div>
    </div>

    <div id="ui-layer">
        <div class="controls-wrapper">
            <div class="btn-group">
                <label class="upload-btn">
                    Select Folder
                    <input type="file" id="folder-input" webkitdirectory directory multiple>
                </label>

                <label class="upload-btn">
                    Select Files
                    <input type="file" id="file-input" multiple accept="image/*">
                </label>
            </div>
            <div class="btn-group">
                <button class="upload-btn" id="screenshot-btn" title="Screenshot (P)">
                    Screenshot
                </button>
                <button class="upload-btn" id="record-btn" title="Record Video (V)">
                    Record
                </button>
            </div>
        </div>
    </div>

    <div id="webcam-wrapper">
        <video id="webcam" autoplay playsinline></video>
        <div id="debug-info">Initializing...</div>
        <canvas id="webcam-preview" style="display:none;"></canvas>
    </div>

    <div id="fps-counter">FPS: --</div>

    <!-- éŸ³é¢‘æ’­æ”¾å™¨ -->
    <audio id="background-music" loop preload="auto">
        <source src="./music/christmas.mp3" type="audio/mpeg">
        <source src="./music/christmas.ogg" type="audio/ogg">
        æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒéŸ³é¢‘æ’­æ”¾ã€‚
    </audio>

    <!-- éŸ³ä¹æ§åˆ¶UI -->
    <div id="music-controls">
        <!-- ä¸¤ä¸ªæŒ‰é’®æ¨ªå‘æ’åˆ— -->
        <div class="music-buttons">
            <div class="music-btn" id="play-pause-btn" title="Play/Pause (M)">
                <span class="music-icon" id="play-icon">â–¶</span>
                <span class="music-icon" id="pause-icon" style="display:none;">â¸</span>
            </div>
            <div class="music-btn" id="mute-btn" title="Mute (N)">
                <span class="music-icon" id="volume-icon">ğŸ”Š</span>
                <span class="music-icon" id="mute-icon" style="display:none;">ğŸ”‡</span>
            </div>
        </div>
        <!-- éŸ³é‡æ§åˆ¶æ”¾åœ¨ä¸‹é¢ -->
        <div class="volume-control">
            <input type="range" id="volume-slider" min="0" max="100" value="50" title="Volume">
            <div class="music-status" id="music-status">Loading...</div>
        </div>
    </div>

    <!-- è‡ªåŠ¨æ’­æ”¾æç¤º -->
    <div id="autoplay-prompt" style="display:none;">
        <div class="prompt-content">
            <div class="prompt-icon">ğŸµ</div>
            <div class="prompt-text">ç‚¹å‡»å¼€å§‹æ’­æ”¾åœ£è¯éŸ³ä¹</div>
            <button class="prompt-btn" id="start-music-btn">å¼€å§‹æ’­æ”¾</button>
        </div>
    </div>

    <script type="module">
        /* ========================================================================
           åœ£è¯æ ‘ç²’å­ç³»ç»Ÿ - Christmas Tree Particle System

           ä»£ç ç»“æ„ç›®å½•:
           1. å¯¼å…¥ä¾èµ–
           2. å·¥å…·å‡½æ•° (Toastæç¤ºç³»ç»Ÿ)
           3. é…ç½®ç®¡ç†
           4. çŠ¶æ€ç®¡ç†
           5. åˆå§‹åŒ–å‡½æ•°
           6. å›¾ç‰‡åŠ è½½ç³»ç»Ÿ
           7. Three.js åˆå§‹åŒ–
           8. çº¹ç†åˆ›å»º
           9. é›ªèŠ±ç³»ç»Ÿ
          10. ç²’å­ç±»å®šä¹‰
          11. ç…§ç‰‡å¸ƒå±€ç®¡ç†
          12. ç²’å­ç³»ç»Ÿåˆ›å»º (InstancedMeshä¼˜åŒ–)
          13. å°˜åŸƒç³»ç»Ÿ (InstancedMeshä¼˜åŒ–)
          14. ç…§ç‰‡åœºæ™¯æ·»åŠ 
          15. ç”¨æˆ·ä¸Šä¼ å¤„ç†
          16. MediaPipeæ‰‹åŠ¿è¯†åˆ«
          17. æ€§èƒ½ç›‘æ§
          18. äº‹ä»¶ç›‘å¬
          19. åŠ¨ç”»å¾ªç¯
          20. å¯åŠ¨åº”ç”¨
        ======================================================================== */

        // ==================== 1. å¯¼å…¥ä¾èµ– ====================
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // ==================== 2. å·¥å…·å‡½æ•° ====================
        const toastIcons = {
            success: 'âœ“',
            error: 'âœ—',
            warning: 'âš ',
            info: 'â„¹'
        };

        function showToast(message, type = 'info', duration = 3000) {
            // åˆ›å»ºtoastå…ƒç´ 
            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;

            // æ·»åŠ å›¾æ ‡
            const icon = document.createElement('div');
            icon.className = 'toast-icon';
            icon.innerText = toastIcons[type] || 'â„¹';

            // æ·»åŠ æ¶ˆæ¯
            const msg = document.createElement('div');
            msg.className = 'toast-message';
            msg.innerText = message;

            toast.appendChild(icon);
            toast.appendChild(msg);
            document.body.appendChild(toast);

            // è‡ªåŠ¨ç§»é™¤
            setTimeout(() => {
                toast.classList.add('toast-exit');
                setTimeout(() => toast.remove(), 300);
            }, duration);

            return toast;
        }

        // å›¾ç‰‡å‹ç¼©å·¥å…·å‡½æ•°
        async function compressImage(imageSource, showProgress = true) {
            if (!CONFIG.imageCompression.enabled) {
                return imageSource;
            }

            try {
                let toastId = null;
                if (showProgress) {
                    toastId = showToast('æ­£åœ¨å‹ç¼©å›¾ç‰‡...', 'info', 0);
                }

                const img = new Image();
                if (typeof imageSource === 'string') {
                    img.src = imageSource;
                } else if (imageSource instanceof Blob) {
                    img.src = URL.createObjectURL(imageSource);
                } else if (imageSource instanceof HTMLImageElement) {
                    img.src = imageSource.src;
                } else {
                    throw new Error('ä¸æ”¯æŒçš„å›¾ç‰‡æ ¼å¼');
                }

                await new Promise((resolve, reject) => {
                    img.onload = resolve;
                    img.onerror = () => reject(new Error('å›¾ç‰‡åŠ è½½å¤±è´¥'));
                });

                const originalWidth = img.naturalWidth || img.width;
                const originalHeight = img.naturalHeight || img.height;
                const { maxWidth, maxHeight, quality, mimeType } = CONFIG.imageCompression;

                let targetWidth = originalWidth;
                let targetHeight = originalHeight;

                // æ£€æŸ¥æ˜¯å¦éœ€è¦å‹ç¼©
                if (originalWidth > maxWidth || originalHeight > maxHeight) {
                    const aspectRatio = originalWidth / originalHeight;
                    if (aspectRatio > 1) {
                        targetWidth = Math.min(originalWidth, maxWidth);
                        targetHeight = Math.round(targetWidth / aspectRatio);
                    } else {
                        targetHeight = Math.min(originalHeight, maxHeight);
                        targetWidth = Math.round(targetHeight * aspectRatio);
                    }

                    if (showProgress && toastId) {
                        toastId.querySelector('.toast-message').innerText =
                            `å‹ç¼©ä¸­: ${originalWidth}Ã—${originalHeight} â†’ ${targetWidth}Ã—${targetHeight}`;
                    }
                } else {
                    // ä¸éœ€è¦å‹ç¼©
                    if (toastId) {
                        toastId.classList.add('toast-exit');
                        setTimeout(() => toastId.remove(), 300);
                    }

                    if (imageSource instanceof Blob) {
                        return URL.createObjectURL(imageSource);
                    }
                    return img.src;
                }

                // Canvas å‹ç¼©
                const canvas = document.createElement('canvas');
                canvas.width = targetWidth;
                canvas.height = targetHeight;
                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                ctx.drawImage(img, 0, 0, targetWidth, targetHeight);

                const compressedBlob = await new Promise((resolve, reject) => {
                    canvas.toBlob(
                        (blob) => blob ? resolve(blob) : reject(new Error('å‹ç¼©å¤±è´¥')),
                        mimeType,
                        quality
                    );
                });

                const originalSize = imageSource instanceof Blob ? imageSource.size : img.src.length;
                const ratio = ((1 - compressedBlob.size / originalSize) * 100).toFixed(1);

                if (imageSource instanceof Blob) {
                    URL.revokeObjectURL(img.src);
                }

                if (toastId) {
                    toastId.classList.add('toast-exit');
                    setTimeout(() => toastId.remove(), 300);
                }

                if (showProgress) {
                    showToast(`å›¾ç‰‡å·²å‹ç¼© ${ratio}% (${targetWidth}Ã—${targetHeight})`, 'success', 2000);
                }

                return URL.createObjectURL(compressedBlob);

            } catch (error) {
                console.error('Image compression failed:', error);
                if (showProgress) {
                    showToast('å›¾ç‰‡å‹ç¼©å¤±è´¥ï¼Œä½¿ç”¨åŸå›¾', 'warning', 2000);
                }

                if (imageSource instanceof Blob) {
                    return URL.createObjectURL(imageSource);
                }
                return typeof imageSource === 'string' ? imageSource : null;
            }
        }

        // æ€§èƒ½ä¼‘çœ ç®¡ç†
        function pauseApp() {
            // é˜²æ­¢é‡å¤æš‚åœ
            if (PERFORMANCE_STATE.isPausing || !PERFORMANCE_STATE.isPageVisible) {
                return;
            }

            PERFORMANCE_STATE.isPausing = true;
            PERFORMANCE_STATE.isPageVisible = false;

            // å–æ¶ˆæ¸²æŸ“å¾ªç¯
            if (PERFORMANCE_STATE.animationFrameId) {
                cancelAnimationFrame(PERFORMANCE_STATE.animationFrameId);
                PERFORMANCE_STATE.animationFrameId = null;
            }

            // å–æ¶ˆ MediaPipe æ£€æµ‹
            if (PERFORMANCE_STATE.mediaPipeFrameId) {
                cancelAnimationFrame(PERFORMANCE_STATE.mediaPipeFrameId);
                PERFORMANCE_STATE.mediaPipeFrameId = null;
            }

            // æš‚åœæ‘„åƒå¤´ï¼ˆä½¿ç”¨å¯é€‰é“¾ï¼‰
            video?.srcObject?.getTracks().forEach(track => track.enabled = false);
            video?.pause();

            // æš‚åœéŸ³ä¹
            if (STATE.music.audio && STATE.music.isPlaying) {
                STATE.music.audio.pause();
            }

            PERFORMANCE_STATE.isPausing = false;
        }

        function resumeApp() {
            // é˜²æ­¢é‡å¤æ¢å¤
            if (PERFORMANCE_STATE.isResuming || PERFORMANCE_STATE.isPageVisible) {
                return;
            }

            PERFORMANCE_STATE.isResuming = true;
            PERFORMANCE_STATE.isPageVisible = true;

            // æ¢å¤æ‘„åƒå¤´ï¼ˆä½¿ç”¨å¯é€‰é“¾ï¼‰
            video?.srcObject?.getTracks().forEach(track => track.enabled = true);
            video?.play().catch(err => console.warn('Camera resume failed:', err));

            // é‡å¯æ¸²æŸ“å¾ªç¯
            if (animate) {
                animate();
            }

            // é‡å¯ MediaPipe æ£€æµ‹
            if (handLandmarker && predictWebcam) {
                predictWebcam();
            }

            // æ¢å¤éŸ³ä¹
            if (STATE.music.audio && STATE.music.isPlaying && !STATE.music.autoplayBlocked) {
                STATE.music.audio.play().catch(err => console.warn('Music resume failed:', err));
            }

            PERFORMANCE_STATE.isResuming = false;
        }

        // ==================== éŸ³ä¹æ’­æ”¾æ§åˆ¶ç³»ç»Ÿ ====================

        // åˆå§‹åŒ–éŸ³ä¹æ’­æ”¾å™¨
        function initMusicPlayer() {
            if (!CONFIG.audio.enabled) {
                console.log('Music player disabled in config');
                document.getElementById('music-controls')?.remove();
                return;
            }

            const audio = document.getElementById('background-music');
            if (!audio) {
                console.error('Audio element not found');
                return;
            }

            STATE.music.audio = audio;

            // ä»localStorageè¯»å–ä¿å­˜çš„éŸ³é‡
            const savedVolume = localStorage.getItem('christmas-music-volume');
            if (savedVolume !== null) {
                STATE.music.volume = parseFloat(savedVolume);
            } else {
                STATE.music.volume = CONFIG.audio.defaultVolume;
            }

            audio.volume = STATE.music.volume;

            // æ›´æ–°éŸ³é‡æ»‘å—
            const volumeSlider = document.getElementById('volume-slider');
            if (volumeSlider) {
                volumeSlider.value = STATE.music.volume * 100;
            }

            // éŸ³é¢‘åŠ è½½å®Œæˆ
            audio.addEventListener('canplaythrough', () => {
                STATE.music.isLoaded = true;
                updateMusicStatus('Ready');
                console.log('Music loaded successfully');
            });

            // éŸ³é¢‘å¼€å§‹æ’­æ”¾
            audio.addEventListener('play', () => {
                STATE.music.isPlaying = true;
                updatePlayPauseButton();
                updateMusicStatus('Playing');
            });

            // éŸ³é¢‘æš‚åœ
            audio.addEventListener('pause', () => {
                STATE.music.isPlaying = false;
                updatePlayPauseButton();
                updateMusicStatus('Paused');
            });

            // éŸ³é¢‘æ’­æ”¾ç»“æŸï¼ˆè™½ç„¶æ˜¯loopï¼Œä½†è¿˜æ˜¯ç›‘å¬ä¸€ä¸‹ï¼‰
            audio.addEventListener('ended', () => {
                STATE.music.isPlaying = false;
                updatePlayPauseButton();
            });

            // éŸ³é¢‘åŠ è½½é”™è¯¯
            audio.addEventListener('error', (e) => {
                console.error('Audio loading error:', e);
                updateMusicStatus('Load Failed');
                showToast('éŸ³ä¹æ–‡ä»¶åŠ è½½å¤±è´¥', 'error', 3000);
            });

            // å°è¯•è‡ªåŠ¨æ’­æ”¾
            if (CONFIG.audio.autoplay) {
                tryAutoplay();
            }
        }

        // å°è¯•è‡ªåŠ¨æ’­æ”¾éŸ³ä¹
        async function tryAutoplay() {
            try {
                const audio = STATE.music.audio;
                if (!audio) return;

                // å¦‚æœå¯ç”¨æ·¡å…¥æ•ˆæœï¼Œå…ˆè®¾ç½®éŸ³é‡ä¸º0
                if (CONFIG.audio.fadeIn) {
                    audio.volume = 0;
                }

                await audio.play();

                STATE.music.autoplayBlocked = false;
                STATE.music.isPlaying = true;

                // æ·¡å…¥æ•ˆæœ
                if (CONFIG.audio.fadeIn) {
                    fadeInMusic();
                }

                console.log('Autoplay successful');
            } catch (error) {
                console.warn('Autoplay blocked by browser:', error);
                STATE.music.autoplayBlocked = true;

                // æ˜¾ç¤ºç”¨æˆ·æç¤º
                const prompt = document.getElementById('autoplay-prompt');
                if (prompt) {
                    prompt.style.display = 'flex';
                }

                updateMusicStatus('Click to Play');
            }
        }

        // éŸ³ä¹æ·¡å…¥æ•ˆæœ
        function fadeInMusic() {
            const audio = STATE.music.audio;
            if (!audio) return;

            const targetVolume = STATE.music.isMuted ? 0 : STATE.music.volume;
            const duration = CONFIG.audio.fadeInDuration;
            const steps = 60; // 60æ­¥
            const stepDuration = duration / steps;
            const volumeIncrement = targetVolume / steps;

            let currentStep = 0;

            const fadeInterval = setInterval(() => {
                currentStep++;
                const newVolume = Math.min(volumeIncrement * currentStep, targetVolume);
                audio.volume = newVolume;

                if (currentStep >= steps) {
                    clearInterval(fadeInterval);
                }
            }, stepDuration);
        }

        // åˆ‡æ¢æ’­æ”¾/æš‚åœ
        function togglePlayPause() {
            const audio = STATE.music.audio;
            if (!audio) return;

            if (STATE.music.isPlaying) {
                audio.pause();
            } else {
                audio.play().catch(err => {
                    console.error('Play failed:', err);
                    showToast('æ’­æ”¾å¤±è´¥', 'error', 2000);
                });
            }
        }

        // åˆ‡æ¢é™éŸ³
        function toggleMute() {
            const audio = STATE.music.audio;
            if (!audio) return;

            STATE.music.isMuted = !STATE.music.isMuted;
            audio.volume = STATE.music.isMuted ? 0 : STATE.music.volume;

            updateMuteButton();
        }

        // è®¾ç½®éŸ³é‡
        function setVolume(value) {
            const audio = STATE.music.audio;
            if (!audio) return;

            STATE.music.volume = value;

            if (!STATE.music.isMuted) {
                audio.volume = value;
            }

            // ä¿å­˜åˆ°localStorage
            localStorage.setItem('christmas-music-volume', value.toString());
        }

        // æ›´æ–°æ’­æ”¾/æš‚åœæŒ‰é’®æ˜¾ç¤º
        function updatePlayPauseButton() {
            const playIcon = document.getElementById('play-icon');
            const pauseIcon = document.getElementById('pause-icon');

            if (STATE.music.isPlaying) {
                playIcon.style.display = 'none';
                pauseIcon.style.display = 'block';
            } else {
                playIcon.style.display = 'block';
                pauseIcon.style.display = 'none';
            }
        }

        // æ›´æ–°é™éŸ³æŒ‰é’®æ˜¾ç¤º
        function updateMuteButton() {
            const volumeIcon = document.getElementById('volume-icon');
            const muteIcon = document.getElementById('mute-icon');

            if (STATE.music.isMuted) {
                volumeIcon.style.display = 'none';
                muteIcon.style.display = 'block';
            } else {
                volumeIcon.style.display = 'block';
                muteIcon.style.display = 'none';
            }
        }

        // æ›´æ–°éŸ³ä¹çŠ¶æ€æ˜¾ç¤º
        function updateMusicStatus(status) {
            const statusElement = document.getElementById('music-status');
            if (statusElement) {
                statusElement.textContent = status;
            }
        }

        // å¼€å§‹æ’­æ”¾éŸ³ä¹ï¼ˆç”¨äºç”¨æˆ·æ‰‹åŠ¨è§¦å‘ï¼‰
        function startMusic() {
            const audio = STATE.music.audio;
            if (!audio) return;

            // å¦‚æœå¯ç”¨æ·¡å…¥æ•ˆæœï¼Œå…ˆè®¾ç½®éŸ³é‡ä¸º0
            if (CONFIG.audio.fadeIn) {
                audio.volume = 0;
            }

            audio.play().then(() => {
                STATE.music.autoplayBlocked = false;
                STATE.music.isPlaying = true;

                // æ·¡å…¥æ•ˆæœ
                if (CONFIG.audio.fadeIn) {
                    fadeInMusic();
                }

                // éšè—æç¤º
                const prompt = document.getElementById('autoplay-prompt');
                if (prompt) {
                    prompt.style.display = 'none';
                }

                showToast('éŸ³ä¹æ’­æ”¾å·²å¼€å§‹', 'success', 2000);
            }).catch(err => {
                console.error('Start music failed:', err);
                showToast('æ’­æ”¾å¤±è´¥ï¼š' + err.message, 'error', 3000);
            });
        }

        // ==================== 3. é…ç½®ç®¡ç† ====================
        // æ ¸å¿ƒé…ç½® (å°†ä»config.jsonåŠ è½½)
        let CONFIG = {
            colors: {
                bg: 0x050d1a,
                fog: 0x050d1a,
                champagneGold: 0xffd966,
                deepGreen: 0x03180a,
                accentRed: 0x990000,
            },
            particles: {
                count: 1500,
                dustCount: 2000,
                snowCount: 1000,
                treeHeight: 24,
                treeRadius: 8
            },
            camera: { z: 50 },
            performance: {
                autoScale: true,
                targetFPS: 60,
                minFPS: 30
            },
            imageCompression: {
                enabled: true,
                maxWidth: 2048,
                maxHeight: 2048,
                quality: 0.90,
                mimeType: 'image/jpeg'
            },
            preload: {
                enabled: true,
                filePattern: '(${i})',
                folder: './images/',
                maxImages: 500,
                maxConsecutiveFails: 10,
                supportedExtensions: ['.jpg', '.jpeg', '.png', '.webp', '.gif', '.bmp']
            },
            audio: {
                enabled: true,
                autoplay: true,
                defaultVolume: 0.5,
                fadeIn: true,
                fadeInDuration: 2000,
                sources: [
                    './music/christmas.mp3',
                    './music/christmas.ogg'
                ]
            }
        };

        // åŠ è½½å¤–éƒ¨é…ç½®
        async function loadConfig() {
            try {
                const response = await fetch('./config.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const config = await response.json();

                // åˆå¹¶é…ç½®ï¼ˆä½¿ç”¨å¯é€‰é“¾å’Œé»˜è®¤å€¼ï¼‰
                CONFIG.particles.count = config?.particles?.tree?.count ?? CONFIG.particles.count;
                CONFIG.particles.dustCount = config?.particles?.dust?.count ?? CONFIG.particles.dustCount;
                CONFIG.particles.snowCount = config?.particles?.snow?.count ?? CONFIG.particles.snowCount;
                CONFIG.particles.treeHeight = config?.particles?.tree?.treeHeight ?? CONFIG.particles.treeHeight;
                CONFIG.particles.treeRadius = config?.particles?.tree?.treeRadius ?? CONFIG.particles.treeRadius;
                CONFIG.camera.z = config?.camera?.defaultZ ?? CONFIG.camera.z;

                // æ€§èƒ½é…ç½®
                if (config?.performance) {
                    CONFIG.performance = {
                        autoScale: config.performance.autoScale ?? CONFIG.performance.autoScale,
                        targetFPS: config.performance.targetFPS ?? CONFIG.performance.targetFPS,
                        minFPS: config.performance.minFPS ?? CONFIG.performance.minFPS
                    };
                }

                // åŠ è½½é¢„åŠ è½½é…ç½®
                if (config?.loader) {
                    CONFIG.preload.filePattern = config.loader.filePattern ?? CONFIG.preload.filePattern;
                    CONFIG.preload.folder = config.loader.folder ?? CONFIG.preload.folder;
                    CONFIG.preload.maxImages = config.loader.maxImages ?? CONFIG.preload.maxImages;
                    CONFIG.preload.maxConsecutiveFails = config.loader.maxConsecutiveFails ?? CONFIG.preload.maxConsecutiveFails;
                    CONFIG.preload.supportedExtensions = config.loader.supportedExtensions ?? CONFIG.preload.supportedExtensions;
                }

                console.log('Configuration loaded successfully');
            } catch (e) {
                console.warn('Failed to load config.json, using defaults', e);
            }
        }

        // ==================== 4. çŠ¶æ€ç®¡ç† ====================
        // å…¨å±€çŠ¶æ€
        const STATE = {
            mode: 'TREE',
            focusIndex: -1,
            focusTarget: null,
            hand: {
                detected: false,
                x: 0,
                y: 0,
                history: [],
                sizeHistory: []
            },
            rotation: { x: 0, y: 0 },
            zoom: 1.0,
            targetZoom: 1.0,
            baseHandSize: 0,
            lastModeChange: 0,
            modeCooldown: 500,
            mouse: {
                isDragging: false,
                isRightDragging: false,
                lastX: 0,
                lastY: 0,
                dragStartTime: 0,
                manualControl: false,
                lastManualTime: 0
            },
            camera: {
                position: { x: 0, y: 0, z: 50 },
                targetPosition: { x: 0, y: 0, z: 50 }
            },
            recording: {
                isRecording: false,
                mediaRecorder: null,
                recordedChunks: [],
                startTime: 0,
                maxDuration: 120000
            },
            music: {
                audio: null,
                isPlaying: false,
                volume: 0.5,
                isMuted: false,
                isLoaded: false,
                autoplayBlocked: false
            }
        };

        // æ€§èƒ½ç®¡ç†çŠ¶æ€
        const PERFORMANCE_STATE = {
            isPageVisible: true,
            animationFrameId: null,
            mediaPipeFrameId: null,
            videoStream: null,
            isPausing: false,
            isResuming: false
        };

        // å›¾ç‰‡åŠ è½½çŠ¶æ€
        const imageLoader = {
            loaded: 0,
            total: 0,
            failed: 0,
            isLoading: false
        };

        // Three.js æ ¸å¿ƒå¯¹è±¡
        let scene, camera, renderer, composer;
        let mainGroup;
        let clock = new THREE.Clock();
        let particleSystem = [];
        let photoMeshGroup = new THREE.Group();
        let handLandmarker, video;
        let caneTexture;
        let snowSystem;
        let raycaster = new THREE.Raycaster();
        let mouseVector = new THREE.Vector2();
        const debugInfo = document.getElementById('debug-info');


        // FPSæ€§èƒ½ç›‘æ§å™¨
        const fpsMonitor = {
            frames: 0,
            lastTime: performance.now(),
            fps: 60,
            counter: null
        };

        // ==================== 5. å›¾ç‰‡é¢„åŠ è½½ç³»ç»Ÿ ====================
        // æ›´æ–°è¿›åº¦æ¡
        function updateProgress() {
            const progressBar = document.getElementById('progress-bar');
            const progressText = document.getElementById('progress-text');

            if (progressBar && progressText) {
                const percentage = imageLoader.total > 0
                    ? Math.round((imageLoader.loaded / imageLoader.total) * 100)
                    : 0;
                progressBar.style.setProperty('--progress', `${percentage}%`);
                progressText.innerText = `${imageLoader.loaded} / ${imageLoader.total}`;
            }
        }

        // åŠ è½½å•å¼ å›¾ç‰‡ï¼ˆä¸æ›´æ–°è®¡æ•°å™¨ï¼Œç”±è°ƒç”¨æ–¹ç®¡ç†ï¼‰
        async function loadSingleImage(url) {
            let compressedUrl = null;
            try {
                compressedUrl = await compressImage(url, false);

                return new Promise((resolve, reject) => {
                    const loader = new THREE.TextureLoader();
                    loader.load(
                        compressedUrl,
                        (texture) => {
                            texture.colorSpace = THREE.SRGBColorSpace;
                            addPhotoToScene(texture);
                            if (compressedUrl && compressedUrl.startsWith('blob:')) {
                                URL.revokeObjectURL(compressedUrl);
                            }
                            resolve();
                        },
                        undefined,
                        (error) => {
                            if (compressedUrl && compressedUrl.startsWith('blob:')) {
                                URL.revokeObjectURL(compressedUrl);
                            }
                            reject(error);
                        }
                    );
                });
            } catch (error) {
                if (compressedUrl && compressedUrl.startsWith('blob:')) {
                    URL.revokeObjectURL(compressedUrl);
                }
                throw error;
            }
        }

        // åŠ è½½é¢„å®šä¹‰å›¾ç‰‡ï¼ˆä¼˜å…ˆçº§å°è¯•å¤šæ ¼å¼ï¼‰
        async function loadPredefinedImages() {
            if (!CONFIG.preload.enabled) {
                console.log('Preload disabled');
                return;
            }

            const { filePattern, folder, maxImages, maxConsecutiveFails, supportedExtensions } = CONFIG.preload;

            imageLoader.loaded = 0;
            imageLoader.failed = 0;
            imageLoader.isLoading = true;

            let consecutiveFails = 0;
            const BATCH_SIZE = 10; // æ‰¹é‡å¹¶å‘åŠ è½½
            const loadTasks = [];

            // å°è¯•åŠ è½½å•ä¸ªåºå·çš„å›¾ç‰‡ï¼ˆæŒ‰æ‰©å±•åä¼˜å…ˆçº§ï¼‰
            async function tryLoadImageByIndex(index) {
                for (const ext of supportedExtensions) {
                    const filename = filePattern.replace('${i}', index) + ext;
                    const url = folder + filename;

                    try {
                        await loadSingleImage(url);
                        imageLoader.loaded++; // æˆåŠŸåŠ è½½ï¼Œè®¡æ•°+1
                        return true;
                    } catch (error) {
                        // å°è¯•ä¸‹ä¸€ä¸ªæ‰©å±•å
                    }
                }
                // æ‰€æœ‰æ‰©å±•åéƒ½å¤±è´¥
                imageLoader.failed++;
                return false;
            }

            // é€ä¸ªåºå·å°è¯•ï¼ˆæ‰¹é‡å¹¶å‘ä¼˜åŒ–ï¼‰
            for (let i = 1; i <= maxImages && consecutiveFails < maxConsecutiveFails; i++) {
                loadTasks.push({index: i});

                // æ¯æ‰¹å¹¶å‘æ‰§è¡Œ
                if (loadTasks.length >= BATCH_SIZE || i === maxImages) {
                    const results = await Promise.allSettled(
                        loadTasks.map(task => tryLoadImageByIndex(task.index))
                    );

                    // æ£€æŸ¥ç»“æœï¼Œæ›´æ–°è¿ç»­å¤±è´¥è®¡æ•°
                    for (const result of results) {
                        if (result.status === 'fulfilled' && result.value) {
                            consecutiveFails = 0; // æˆåŠŸåˆ™é‡ç½®
                        } else {
                            consecutiveFails++; // å¤±è´¥åˆ™ç´¯åŠ 
                            if (consecutiveFails >= maxConsecutiveFails) {
                                console.log(`Stopped after ${consecutiveFails} consecutive fails`);
                                break;
                            }
                        }
                    }

                    loadTasks.length = 0; // æ¸…ç©ºä»»åŠ¡é˜Ÿåˆ—

                    // è¾¾åˆ°ä¸Šé™åˆ™åœæ­¢
                    if (consecutiveFails >= maxConsecutiveFails) {
                        break;
                    }
                }
            }

            imageLoader.isLoading = false;

            const successCount = imageLoader.loaded;
            console.log(`Image loading complete: loaded=${imageLoader.loaded}, failed=${imageLoader.failed}`);

            if (successCount > 0) {
                showToast(`æˆåŠŸåŠ è½½ ${successCount} å¼ ç…§ç‰‡`, 'success', 5000);
            } else {
                showToast('æœªæ‰¾åˆ°é¢„åŠ è½½å›¾ç‰‡', 'warning', 5000);
            }
        }

        // ==================== 6. åˆå§‹åŒ–å‡½æ•° ====================
        async function init() {
            const loader = document.getElementById('loader');

            try {
                // åŠ è½½é…ç½®
                await loadConfig();

                // åˆå§‹åŒ–UIå…ƒç´ 
                fpsMonitor.counter = document.getElementById('fps-counter');

                // åˆå§‹åŒ–Three.jsåœºæ™¯ï¼ˆå¯èƒ½å¤±è´¥ï¼‰
                try {
                    initThree();
                    setupEnvironment();
                    setupLights();
                    createTextures();
                    createParticles();
                    createDust();
                    createSnow();
                    setupPostProcessing();
                } catch (e) {
                    console.error('Three.js initialization failed:', e);
                    showToast('3Dåœºæ™¯åˆå§‹åŒ–å¤±è´¥ï¼Œéƒ¨åˆ†åŠŸèƒ½ä¸å¯ç”¨', 'error', 5000);
                    throw e; // 3Dåœºæ™¯æ˜¯æ ¸å¿ƒåŠŸèƒ½ï¼Œå¤±è´¥åˆ™ç»ˆæ­¢
                }

                setupEvents();

                // åˆå§‹åŒ–éŸ³ä¹æ’­æ”¾å™¨ï¼ˆåœ¨äº‹ä»¶ç›‘å¬ä¹‹åï¼‰
                initMusicPlayer();

                // åˆå§‹åŒ–æ‰‹åŠ¿è¯†åˆ«ï¼ˆå¯é€‰åŠŸèƒ½ï¼Œå¤±è´¥å¯é™çº§ï¼‰
                try {
                    await initMediaPipe();
                } catch (e) {
                    console.error('MediaPipe initialization failed:', e);
                    showToast('æ‰‹åŠ¿è¯†åˆ«åˆå§‹åŒ–å¤±è´¥ï¼Œè¯·ä½¿ç”¨é¼ æ ‡æ§åˆ¶', 'warning', 5000);
                    // é™çº§ï¼šç»§ç»­è¿è¡Œä½†ç¦ç”¨æ‰‹åŠ¿åŠŸèƒ½
                }

                // é¢„åŠ è½½å›¾ç‰‡ï¼ˆå¯é€‰åŠŸèƒ½ï¼Œå¤±è´¥å¯é™çº§ï¼‰
                try {
                    await loadPredefinedImages();
                } catch (e) {
                    console.error('Image preload failed:', e);
                    showToast('å›¾ç‰‡é¢„åŠ è½½å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨ä¸Šä¼ ', 'warning', 3000);
                    // é™çº§ï¼šç»§ç»­è¿è¡Œï¼Œç”¨æˆ·å¯æ‰‹åŠ¨ä¸Šä¼ 
                }

                // éšè—åŠ è½½åŠ¨ç”»
                if (loader) {
                    loader.style.opacity = 0;
                    setTimeout(() => loader.remove(), 800);
                }

                // å¯åŠ¨æ¸²æŸ“å¾ªç¯
                animate();

            } catch (error) {
                console.error('Critical initialization error:', error);

                // æ˜¾ç¤ºè‡´å‘½é”™è¯¯
                if (loader) {
                    loader.innerHTML = `
                        <div style="color: #ff4444; text-align: center; padding: 20px;">
                            <h2 style="color: #d4af37; margin-bottom: 20px;">åˆå§‹åŒ–å¤±è´¥</h2>
                            <p style="color: #ff6666; margin: 10px 0;">${error.message || 'æœªçŸ¥é”™è¯¯'}</p>
                            <p style="color: #999; font-size: 14px; margin-top: 20px;">è¯·åˆ·æ–°é¡µé¢é‡è¯•</p>
                            <button onclick="location.reload()" style="
                                margin-top: 20px;
                                padding: 10px 30px;
                                background: rgba(212, 175, 55, 0.2);
                                border: 1px solid #d4af37;
                                color: #d4af37;
                                cursor: pointer;
                                text-transform: uppercase;
                                letter-spacing: 2px;
                            ">åˆ·æ–°é¡µé¢</button>
                        </div>
                    `;
                    loader.style.opacity = 1;
                }
            }
        }

        // ==================== 6. Three.js åœºæ™¯åˆå§‹åŒ– ====================
        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            // è®©åœºæ™¯èƒŒæ™¯é€æ˜ï¼Œä»¥ä¾¿æ˜¾ç¤ºèƒŒæ™¯æ ‡é¢˜
            scene.background = null;  // è®¾ç½®ä¸ºnullä½¿èƒŒæ™¯é€æ˜
            scene.fog = new THREE.FogExp2(CONFIG.colors.fog, 0.015); // è°ƒæ•´é›¾æ°”æµ“åº¦

            camera = new THREE.PerspectiveCamera(42, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, CONFIG.camera.z); 

            // å¯ç”¨ alpha: true ä»¥ä¾¿æœªæ¥å¦‚æœæœ‰éœ€è¦å¯ä»¥é€è¿‡èƒŒæ™¯
            // preserveDrawingBuffer: true æ˜¯ä¸ºäº†è®©canvaså¯ä»¥è¢«æˆªå›¾ï¼ˆhtml2canvasæˆ–toDataURLï¼‰
            renderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: true,
                powerPreference: "high-performance",
                preserveDrawingBuffer: true  // å…³é”®ï¼šä¿ç•™ç»˜åˆ¶ç¼“å†²åŒºç”¨äºæˆªå›¾
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ReinhardToneMapping; 
            renderer.toneMappingExposure = 2.2; 
            container.appendChild(renderer.domElement);

            mainGroup = new THREE.Group();
            scene.add(mainGroup);
        }

        function setupEnvironment() {
            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;
        }

        function setupLights() {
            const ambient = new THREE.AmbientLight(0xffffff, 0.6); // ç¨å¾®æé«˜ç¯å¢ƒå…‰
            scene.add(ambient);

            const innerLight = new THREE.PointLight(0xffaa00, 2, 20);
            innerLight.position.set(0, 5, 0);
            mainGroup.add(innerLight);

            const spotGold = new THREE.SpotLight(0xffcc66, 1200);
            spotGold.position.set(30, 40, 40);
            spotGold.angle = 0.5;
            spotGold.penumbra = 0.5;
            scene.add(spotGold);

            const spotBlue = new THREE.SpotLight(0x6688ff, 800); // å¢å¼ºè“è‰²èƒŒå…‰ï¼Œè¥é€ æœˆå…‰æ„Ÿ
            spotBlue.position.set(-30, 20, -30);
            scene.add(spotBlue);
            
            const fill = new THREE.DirectionalLight(0xffeebb, 0.8);
            fill.position.set(0, 0, 50);
            scene.add(fill);
        }

        function setupPostProcessing() {
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.65;
            bloomPass.strength = 0.5;
            bloomPass.radius = 0.4;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);
        }

        // ==================== 8. çº¹ç†åˆ›å»º ====================
        function createTextures() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0,0,128,128);
            ctx.fillStyle = '#880000';
            ctx.beginPath();
            for(let i=-128; i<256; i+=32) {
                ctx.moveTo(i, 0); ctx.lineTo(i+32, 128); ctx.lineTo(i+16, 128); ctx.lineTo(i-16, 0);
            }
            ctx.fill();
            caneTexture = new THREE.CanvasTexture(canvas);
            caneTexture.wrapS = THREE.RepeatWrapping;
            caneTexture.wrapT = THREE.RepeatWrapping;
            caneTexture.repeat.set(3, 3);
        }

        // ==================== 9. é›ªèŠ±ç³»ç»Ÿ ====================
        function createSnow() {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const velocities = [];
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const context = canvas.getContext('2d');
            context.fillStyle = 'white';
            context.beginPath();
            context.arc(16, 16, 16, 0, Math.PI * 2);
            context.fill();
            const snowTexture = new THREE.CanvasTexture(canvas);

            // åˆå§‹åŒ–é›ªèŠ±ä½ç½®å’Œå±æ€§
            for (let i = 0; i < CONFIG.particles.snowCount; i++) {
                const x = THREE.MathUtils.randFloatSpread(100);
                const y = THREE.MathUtils.randFloatSpread(60);
                const z = THREE.MathUtils.randFloatSpread(60);
                vertices.push(x, y, z);

                // å­˜å‚¨æ¯ä¸ªé›ªèŠ±çš„é€Ÿåº¦å’Œæ‘†åŠ¨å‚æ•°
                velocities.push(
                    Math.random() * 0.2 + 0.1, // fall speed
                    Math.random() * 0.05       // sway speed
                );
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('userData', new THREE.Float32BufferAttribute(velocities, 2));

            const material = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.4,
                map: snowTexture,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            const snow = new THREE.Points(geometry, material);
            scene.add(snow);
            snowSystem = snow;
        }

        function updateSnow(dt) {
            if (!snowSystem) return;

            const positions = snowSystem.geometry.attributes.position.array;
            const userData = snowSystem.geometry.attributes.userData.array;
            const speedFactor = 35.0; 

            for (let i = 0; i < CONFIG.particles.snowCount; i++) {
                // Yè½´ä¸‹è½
                const fallSpeed = userData[i * 2];
                positions[i * 3 + 1] -= fallSpeed * dt * speedFactor;

                // Xè½´æ‘‡æ‘†
                const swaySpeed = userData[i * 2 + 1];
                positions[i * 3] += Math.sin(clock.elapsedTime * 2 + i) * swaySpeed * 0.1;

                // å¾ªç¯é‡ç½®
                if (positions[i * 3 + 1] < -30) {
                    positions[i * 3 + 1] = 30;
                    positions[i * 3] = THREE.MathUtils.randFloatSpread(100);
                    positions[i * 3 + 2] = THREE.MathUtils.randFloatSpread(60);
                }
            }
            snowSystem.geometry.attributes.position.needsUpdate = true;
        }

        // ==================== 10. ç²’å­ç±»å®šä¹‰ ====================
        // ç®¡ç†å•ä¸ªç²’å­çš„ä½ç½®ã€æ—‹è½¬ã€ç¼©æ”¾å’ŒåŠ¨ç”»
        class Particle {
            constructor(mesh, type, isDust = false, instanceId = -1, instancedMesh = null) {
                this.mesh = mesh;
                this.type = type;
                this.isDust = isDust;
                this.instanceId = instanceId;
                this.instancedMesh = instancedMesh;

                this.posTree = new THREE.Vector3();
                this.posScatter = new THREE.Vector3();
                this.position = new THREE.Vector3();
                this.rotation = new THREE.Euler();
                this.scale = new THREE.Vector3(1, 1, 1);

                // å¯¹äºinstanced meshï¼Œä»ä¸´æ—¶meshè·å–åˆå§‹scale
                if (instancedMesh) {
                    this.baseScale = mesh.scale.x;
                } else {
                    this.baseScale = mesh.scale.x;
                }

                const speedMult = (type === 'PHOTO') ? 0.3 : 2.0;

                this.spinSpeed = new THREE.Vector3(
                    (Math.random() - 0.5) * speedMult,
                    (Math.random() - 0.5) * speedMult,
                    (Math.random() - 0.5) * speedMult
                );

                // åˆå§‹æ—‹è½¬
                this.rotation.set(
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2
                );

                this.calculatePositions();
            }

            calculatePositions() {
                if (this.type === 'PHOTO') {
                    // ç…§ç‰‡çš„posTreeç”±updatePhotoLayoutè®¾ç½®ï¼Œè¿™é‡Œä¸åˆå§‹åŒ–
                    // posTreeä¼šåœ¨addPhotoToSceneæœ«å°¾é€šè¿‡updatePhotoLayoutæ­£ç¡®è®¾ç½®
                    const rScatter = 8 + Math.random()*12;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    this.posScatter.set(
                        rScatter * Math.sin(phi) * Math.cos(theta),
                        rScatter * Math.sin(phi) * Math.sin(theta),
                        rScatter * Math.cos(phi)
                    );
                    return;
                }

                const h = CONFIG.particles.treeHeight;
                const halfH = h / 2;
                let t = Math.random(); 
                t = Math.pow(t, 0.8); 
                const y = (t * h) - halfH;
                
                let rMax = CONFIG.particles.treeRadius * (1.0 - t); 
                if (rMax < 0.5) rMax = 0.5;

                const angle = t * 50 * Math.PI + Math.random() * Math.PI; 
                const r = rMax * (0.8 + Math.random() * 0.4); 
                this.posTree.set(Math.cos(angle) * r, y, Math.sin(angle) * r);

                let rScatter = this.isDust ? (12 + Math.random()*20) : (8 + Math.random()*12);
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                this.posScatter.set(
                    rScatter * Math.sin(phi) * Math.cos(theta),
                    rScatter * Math.sin(phi) * Math.sin(theta),
                    rScatter * Math.cos(phi)
                );
            }

            update(dt, mode, focusTargetMesh) {
                let target = this.posTree;

                if (mode === 'SCATTER') target = this.posScatter;
                else if (mode === 'FOCUS') {
                    if (this.mesh === focusTargetMesh) {
                        // å°†ç…§ç‰‡å®šä½åœ¨ç›¸æœºå‰æ–¹20å•ä½å¤„
                        const cameraDirection = new THREE.Vector3();
                        camera.getWorldDirection(cameraDirection);
                        const distanceFromCamera = 20;
                        const desiredWorldPos = new THREE.Vector3()
                            .copy(camera.position)
                            .add(cameraDirection.multiplyScalar(distanceFromCamera));
                        const invMatrix = new THREE.Matrix4().copy(mainGroup.matrixWorld).invert();
                        target = desiredWorldPos.applyMatrix4(invMatrix);
                    } else {
                        target = this.posScatter;
                    }
                }

                const lerpSpeed = (mode === 'FOCUS' && this.mesh === focusTargetMesh) ? 5.0 : 2.0;

                // æ›´æ–°ä½ç½®
                if (this.instancedMesh) {
                    this.position.lerp(target, lerpSpeed * dt);
                } else {
                    this.mesh.position.lerp(target, lerpSpeed * dt);
                }

                // æ›´æ–°æ—‹è½¬
                if (mode === 'SCATTER') {
                    this.rotation.x += this.spinSpeed.x * dt;
                    this.rotation.y += this.spinSpeed.y * dt;
                    this.rotation.z += this.spinSpeed.z * dt;
                } else if (mode === 'TREE') {
                    if (this.type === 'PHOTO') {
                        if (this.instancedMesh) {
                            // å¯¹äºç…§ç‰‡ï¼Œæœå‘ä¸­å¿ƒ
                            const lookAtPos = new THREE.Vector3(0, this.position.y, 0);
                            const direction = new THREE.Vector3().subVectors(this.position, lookAtPos).normalize();
                            this.rotation.y = Math.atan2(direction.x, direction.z);
                        } else {
                            this.mesh.lookAt(0, this.mesh.position.y, 0);
                            this.mesh.rotateY(Math.PI);

                            // {{ æ–°å¢ï¼šæŠŠè®¡ç®—å‡ºçš„æ•´é½è§’åº¦ï¼ŒåŒæ­¥ç»™ this.rotation }}
                            this.rotation.copy(this.mesh.rotation);
                        }
                    } else {
                        this.rotation.x = THREE.MathUtils.lerp(this.rotation.x, 0, dt);
                        this.rotation.z = THREE.MathUtils.lerp(this.rotation.z, 0, dt);
                        this.rotation.y += 0.5 * dt;
                    }
                }

                if (mode === 'FOCUS' && this.mesh === focusTargetMesh) {
                    if (!this.instancedMesh) {
                        this.mesh.lookAt(camera.position);

                        // {{ æ–°å¢ï¼šèšç„¦æ—¶ä¹Ÿè¦æŠŠæœå‘æ‘„åƒæœºçš„è§’åº¦åŒæ­¥ç»™ this.rotation }}
                        this.rotation.copy(this.mesh.rotation);
                    }
                }

                // æ›´æ–°ç¼©æ”¾
                let s = this.baseScale;
                if (this.isDust) {
                    s = this.baseScale * (0.8 + 0.4 * Math.sin(clock.elapsedTime * 4 + (this.instanceId >= 0 ? this.instanceId : this.mesh.id)));
                    if (mode === 'TREE') s = 0;
                } else if (mode === 'SCATTER' && this.type === 'PHOTO') {
                    s = this.baseScale * 2.5;
                } else if (mode === 'FOCUS') {
                    if (this.mesh === focusTargetMesh) s = 4.5;
                    else s = this.baseScale * 0.8;
                }

                this.scale.lerp(new THREE.Vector3(s, s, s), 4 * dt);

                // å¯¹äºInstancedMeshï¼Œæ›´æ–°çŸ©é˜µ
                if (this.instancedMesh && this.instanceId >= 0) {
                    const matrix = new THREE.Matrix4();
                    matrix.compose(this.position, new THREE.Quaternion().setFromEuler(this.rotation), this.scale);
                    this.instancedMesh.setMatrixAt(this.instanceId, matrix);
                    this.instancedMesh.instanceMatrix.needsUpdate = true;
                } else if (!this.instancedMesh) {
                    // æ™®é€šmeshæ›´æ–°scale
                    this.mesh.scale.lerp(new THREE.Vector3(s, s, s), 4 * dt);
                    
                    // {{ æ–°å¢ï¼šæœ€ç»ˆåº”ç”¨æ—‹è½¬ }}
                    this.mesh.rotation.copy(this.rotation);
                }
            }
        }

        // ==================== 11. ç…§ç‰‡å¸ƒå±€ç®¡ç† ====================

        // å°†ç…§ç‰‡æŒ‰èºæ—‹æ’åˆ—åœ¨åœ£è¯æ ‘ä¸Š
        function updatePhotoLayout() {
            const photos = particleSystem.filter(p => p.type === 'PHOTO');
            const count = photos.length;
            if (count === 0) return;

            const h = CONFIG.particles.treeHeight * 0.9;
            const bottomY = -h/2;
            const stepY = h / count;
            const loops = 3;

            photos.forEach((p, i) => {
                const y = bottomY + stepY * i + stepY/2;
                const fullH = CONFIG.particles.treeHeight;
                const normalizedH = (y + fullH/2) / fullH; 

                let rMax = CONFIG.particles.treeRadius * (1.0 - normalizedH);
                if (rMax < 1.0) rMax = 1.0;
                
                const r = rMax + 3.0; 
                const angle = normalizedH * Math.PI * 2 * loops + (Math.PI/4); 

                p.posTree.set(Math.cos(angle) * r, y, Math.sin(angle) * r);
            });
        }

        // ==================== 12. ç²’å­ç³»ç»Ÿåˆ›å»ºï¼ˆInstancedMeshä¼˜åŒ–ï¼‰====================
        // ä½¿ç”¨InstancedMeshå‡å°‘DrawCallï¼Œæå‡æ€§èƒ½
        function createParticles() {
            // å‡ ä½•ä½“å®šä¹‰
            const sphereGeo = new THREE.SphereGeometry(0.5, 32, 32);
            const boxGeo = new THREE.BoxGeometry(0.55, 0.55, 0.55);
            const curve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(0, -0.5, 0), new THREE.Vector3(0, 0.3, 0),
                new THREE.Vector3(0.1, 0.5, 0), new THREE.Vector3(0.3, 0.4, 0)
            ]);
            const candyGeo = new THREE.TubeGeometry(curve, 16, 0.08, 8, false);

            // æè´¨å®šä¹‰
            const goldMat = new THREE.MeshStandardMaterial({
                color: CONFIG.colors.champagneGold,
                metalness: 1.0, roughness: 0.1,
                envMapIntensity: 2.0,
                emissive: 0x443300,
                emissiveIntensity: 0.3
            });

            const greenMat = new THREE.MeshStandardMaterial({
                color: CONFIG.colors.deepGreen,
                metalness: 0.2, roughness: 0.8,
                emissive: 0x002200,
                emissiveIntensity: 0.2
            });

            const redMat = new THREE.MeshPhysicalMaterial({
                color: CONFIG.colors.accentRed,
                metalness: 0.3, roughness: 0.2, clearcoat: 1.0,
                emissive: 0x330000
            });

            const candyMat = new THREE.MeshStandardMaterial({ map: caneTexture, roughness: 0.4 });

            // è®¡ç®—æ¯ç§ç±»å‹çš„æ•°é‡
            const counts = {
                BOX: Math.floor(CONFIG.particles.count * 0.40),
                GOLD_BOX: Math.floor(CONFIG.particles.count * 0.30),
                GOLD_SPHERE: Math.floor(CONFIG.particles.count * 0.22),
                RED: Math.floor(CONFIG.particles.count * 0.05),
                CANE: 0
            };
            counts.CANE = CONFIG.particles.count - (counts.BOX + counts.GOLD_BOX + counts.GOLD_SPHERE + counts.RED);

            // åˆ›å»ºInstancedMesh
            const instances = {};
            instances.BOX = new THREE.InstancedMesh(boxGeo, greenMat, counts.BOX);
            instances.GOLD_BOX = new THREE.InstancedMesh(boxGeo, goldMat, counts.GOLD_BOX);
            instances.GOLD_SPHERE = new THREE.InstancedMesh(sphereGeo, goldMat, counts.GOLD_SPHERE);
            instances.RED = new THREE.InstancedMesh(sphereGeo, redMat, counts.RED);
            instances.CANE = new THREE.InstancedMesh(candyGeo, candyMat, counts.CANE);

            // æ·»åŠ åˆ°åœºæ™¯
            Object.values(instances).forEach(inst => mainGroup.add(inst));

            // åˆ›å»ºç²’å­å¹¶è®¾ç½®åˆå§‹çŸ©é˜µ
            const counters = { BOX: 0, GOLD_BOX: 0, GOLD_SPHERE: 0, RED: 0, CANE: 0 };

            for (let i = 0; i < CONFIG.particles.count; i++) {
                const rand = Math.random();
                let type;

                if (rand < 0.40) type = 'BOX';
                else if (rand < 0.70) type = 'GOLD_BOX';
                else if (rand < 0.92) type = 'GOLD_SPHERE';
                else if (rand < 0.97) type = 'RED';
                else type = 'CANE';

                const instanceId = counters[type]++;
                const instancedMesh = instances[type];

                // åˆ›å»ºä¸´æ—¶meshç”¨äºå­˜å‚¨åˆå§‹å˜æ¢
                const tempMesh = new THREE.Object3D();
                const s = 0.4 + Math.random() * 0.5;
                tempMesh.scale.set(s, s, s);

                const particle = new Particle(tempMesh, type, false, instanceId, instancedMesh);
                particleSystem.push(particle);

                // è®¾ç½®åˆå§‹çŸ©é˜µ
                const matrix = new THREE.Matrix4();
                matrix.compose(particle.position, new THREE.Quaternion().setFromEuler(particle.rotation), particle.scale);
                instancedMesh.setMatrixAt(instanceId, matrix);
            }

            // æ›´æ–°æ‰€æœ‰instanceçŸ©é˜µ
            Object.values(instances).forEach(inst => {
                inst.instanceMatrix.needsUpdate = true;
            });

            // åˆ›å»ºæ˜Ÿæ˜Ÿï¼ˆä¿æŒåŸæ ·ï¼‰
            const starShape = new THREE.Shape();
            const points = 5;
            const outerRadius = 1.5;
            const innerRadius = 0.7;

            for (let i = 0; i < points * 2; i++) {
                const angle = (i * Math.PI) / points + Math.PI / 2;
                const r = (i % 2 === 0) ? outerRadius : innerRadius;
                const x = Math.cos(angle) * r;
                const y = Math.sin(angle) * r;
                if (i === 0) starShape.moveTo(x, y);
                else starShape.lineTo(x, y);
            }
            starShape.closePath();

            const starGeo = new THREE.ExtrudeGeometry(starShape, {
                depth: 0.4,
                bevelEnabled: true,
                bevelThickness: 0.1,
                bevelSize: 0.1,
                bevelSegments: 2
            });
            starGeo.center();

            const starMat = new THREE.MeshStandardMaterial({
                color: 0xffdd88, emissive: 0xffaa00, emissiveIntensity: 1.0,
                metalness: 1.0, roughness: 0
            });
            const star = new THREE.Mesh(starGeo, starMat);
            star.position.set(0, CONFIG.particles.treeHeight / 2 + 1.2, 0);
            mainGroup.add(star);

            mainGroup.add(photoMeshGroup);
        }

        // ==================== 13. å°˜åŸƒç³»ç»Ÿï¼ˆInstancedMeshä¼˜åŒ–ï¼‰====================
        function createDust() {
            const geo = new THREE.TetrahedronGeometry(0.08, 0);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffeebb, transparent: true, opacity: 0.8 });

            // ä½¿ç”¨InstancedMeshä¼˜åŒ–å°˜åŸƒç²’å­
            const dustInstanced = new THREE.InstancedMesh(geo, mat, CONFIG.particles.dustCount);
            mainGroup.add(dustInstanced);

            for (let i = 0; i < CONFIG.particles.dustCount; i++) {
                const tempMesh = new THREE.Object3D();
                const s = 0.5 + Math.random();
                tempMesh.scale.setScalar(s);

                const particle = new Particle(tempMesh, 'DUST', true, i, dustInstanced);
                particleSystem.push(particle);

                // è®¾ç½®åˆå§‹çŸ©é˜µ
                const matrix = new THREE.Matrix4();
                matrix.compose(particle.position, new THREE.Quaternion().setFromEuler(particle.rotation), particle.scale);
                dustInstanced.setMatrixAt(i, matrix);
            }

            dustInstanced.instanceMatrix.needsUpdate = true;
        }

        // ==================== 14. ç…§ç‰‡æ·»åŠ åˆ°åœºæ™¯ ====================
        function addPhotoToScene(texture) {
            const frameGeo = new THREE.BoxGeometry(1.4, 1.4, 0.05);
            const frameMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.champagneGold, metalness: 1.0, roughness: 0.1 });
            const frame = new THREE.Mesh(frameGeo, frameMat);

            let width = 1.2;
            let height = 1.2;
            
            if (texture.image) {
                const aspect = texture.image.width / texture.image.height;
                if (aspect > 1) {
                    height = width / aspect;
                } else {
                    width = height * aspect;
                }
            }

            const photoGeo = new THREE.PlaneGeometry(width, height);
            const photoMat = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
            const photo = new THREE.Mesh(photoGeo, photoMat);
            photo.position.z = 0.04;

            const group = new THREE.Group();
            group.add(frame);
            group.add(photo);
            
            frame.scale.set(width/1.2, height/1.2, 1);

            const s = 0.8;
            group.scale.set(s,s,s);
            
            photoMeshGroup.add(group);
            const particle = new Particle(group, 'PHOTO', false);
            particleSystem.push(particle);

            updatePhotoLayout();

            // è®¾ç½®ç…§ç‰‡çš„åˆå§‹ä½ç½®ä¸ºèºæ—‹ä½ç½®ï¼ˆè€Œä¸æ˜¯ä»åŸç‚¹å¼€å§‹lerpï¼‰
            group.position.copy(particle.posTree);
        }
        
        // ==================== 15. ç”¨æˆ·ä¸Šä¼ å¤„ç† ====================
        // å¢å¼ºæ–‡ä»¶éªŒè¯å‡½æ•°
        function isValidImageFile(file) {
            // 1. æ£€æŸ¥ MIME ç±»å‹
            if (!file.type.startsWith('image/')) {
                return false;
            }

            // 2. æ£€æŸ¥æ–‡ä»¶æ‰©å±•å
            const validExtensions = ['.jpg', '.jpeg', '.png', '.webp', '.gif', '.bmp'];
            const fileName = file.name.toLowerCase();
            const hasValidExt = validExtensions.some(ext => fileName.endsWith(ext));

            if (!hasValidExt) {
                console.warn(`Invalid file extension: ${file.name}`);
                return false;
            }

            // 3. æ£€æŸ¥æ–‡ä»¶å¤§å°ï¼ˆæœ€å¤§50MBï¼‰
            const MAX_SIZE = 50 * 1024 * 1024;
            if (file.size > MAX_SIZE) {
                console.warn(`File too large: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)}MB)`);
                showToast(`æ–‡ä»¶è¿‡å¤§: ${file.name} (æœ€å¤§50MB)`, 'warning', 3000);
                return false;
            }

            // 4. æ£€æŸ¥æ–‡ä»¶å¤§å°ä¸ä¸º0
            if (file.size === 0) {
                console.warn(`Empty file: ${file.name}`);
                return false;
            }

            return true;
        }

        async function handleImageUpload(e) {
            const files = e.target.files;
            if (!files.length) return;

            // ä½¿ç”¨å¢å¼ºéªŒè¯
            const imageFiles = Array.from(files).filter(isValidImageFile);
            if (imageFiles.length === 0) {
                showToast('æœªé€‰æ‹©æœ‰æ•ˆçš„å›¾ç‰‡æ–‡ä»¶', 'warning', 2000);
                return;
            }

            showToast(`æ­£åœ¨å¤„ç† ${imageFiles.length} å¼ å›¾ç‰‡...`, 'info', 2000);

            let successCount = 0;
            let failCount = 0;

            // æ‰¹é‡å¤„ç†å›¾ç‰‡
            for (let i = 0; i < imageFiles.length; i++) {
                const file = imageFiles[i];
                let compressedUrl = null;

                try {
                    // å‹ç¼©å›¾ç‰‡ï¼ˆæ˜¾ç¤ºè¿›åº¦æç¤ºï¼‰
                    compressedUrl = await compressImage(file, true);

                    // åŠ è½½å‹ç¼©åçš„å›¾ç‰‡åˆ° Three.js çº¹ç†
                    await new Promise((resolve, reject) => {
                        const loader = new THREE.TextureLoader();
                        loader.load(
                            compressedUrl,
                            (texture) => {
                                texture.colorSpace = THREE.SRGBColorSpace;
                                addPhotoToScene(texture);
                                if (compressedUrl && compressedUrl.startsWith('blob:')) {
                                    URL.revokeObjectURL(compressedUrl);
                                }
                                successCount++;
                                resolve();
                            },
                            undefined,
                            (error) => {
                                console.error('Failed to load texture:', error);
                                if (compressedUrl && compressedUrl.startsWith('blob:')) {
                                    URL.revokeObjectURL(compressedUrl);
                                }
                                failCount++;
                                reject(error);
                            }
                        );
                    });

                } catch (error) {
                    console.error('Failed to process image:', file.name, error);
                    if (compressedUrl && compressedUrl.startsWith('blob:')) {
                        URL.revokeObjectURL(compressedUrl);
                    }
                    failCount++;
                }
            }

            // æ˜¾ç¤ºæœ€ç»ˆç»“æœ
            if (successCount > 0) {
                showToast(
                    `æˆåŠŸæ·»åŠ  ${successCount} å¼ ç…§ç‰‡${failCount > 0 ? ` (å¤±è´¥ ${failCount} å¼ )` : ''}`,
                    'success',
                    3000
                );
            } else {
                showToast('æ‰€æœ‰ç…§ç‰‡åŠ è½½å¤±è´¥', 'error', 3000);
            }
        }

        // ==================== 16. æˆªå›¾å’Œè§†é¢‘å½•åˆ¶åŠŸèƒ½ ====================

        // è´¨é‡é…ç½®
        const QUALITY_PRESETS = {
            screenshot: {
                standard: {
                    scale: 2,
                    rendererPixelRatio: null,  // ä¸æ”¹å˜
                    description: 'Standard - Fast, smaller file size'
                },
                high: {
                    scale: () => Math.max(2.5, window.devicePixelRatio * 1.5),  // åŠ¨æ€è®¡ç®—
                    rendererPixelRatio: 2,
                    description: 'High - Balanced quality (Recommended)'
                },
                ultra: {
                    scale: 4,
                    rendererPixelRatio: 3,
                    description: 'Ultra - Best quality, larger file & slower'
                }
            },
            recording: {
                standard: {
                    width: 1920,
                    height: 1080,
                    frameRate: 30,
                    bitrate: 5000000,  // 5 Mbps
                    description: 'Standard - 1080p, 5Mbps'
                },
                high: {
                    width: () => Math.round(window.innerWidth * 1.5),  // åŠ¨æ€è®¡ç®—
                    height: () => Math.round(window.innerHeight * 1.5),
                    frameRate: 30,
                    bitrate: 10000000,  // 10 Mbps
                    description: 'High - 1.5x current resolution, 10Mbps'
                },
                ultra: {
                    width: 2560,
                    height: 1440,
                    frameRate: 30,
                    bitrate: 15000000,  // 15 Mbps
                    description: 'Ultra - 2K, 15Mbps'
                }
            }
        };

        // ç”Ÿæˆæ—¶é—´æˆ³ï¼ˆç”¨äºæ–‡ä»¶åï¼‰
        function getTimestamp() {
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');
            return `${year}${month}${day}_${hours}${minutes}${seconds}`;
        }

        // æˆªå›¾åŠŸèƒ½ - æ•è·æ•´ä¸ªUIç•Œé¢ï¼ˆå›ºå®šUltraè´¨é‡ï¼‰
        // ä½¿ç”¨æ–¹æ¡ˆCï¼š3Dåœºæ™¯ + æ‰‹åŠ¨ç»˜åˆ¶UIå…ƒç´ 
        async function takeScreenshot() {
            try {
                // å›ºå®šä½¿ç”¨Ultraè´¨é‡
                const quality = 'ultra';
                const preset = QUALITY_PRESETS.screenshot[quality];

                showToast('æ­£åœ¨ç”Ÿæˆè¶…æ¸…æˆªå›¾...', 'info', 1500);

                // ä¿å­˜åŸå§‹pixelRatio
                const originalPixelRatio = renderer.getPixelRatio();

                // ä¸´æ—¶æé«˜Three.jsæ¸²æŸ“è´¨é‡
                if (preset.rendererPixelRatio) {
                    renderer.setPixelRatio(preset.rendererPixelRatio);
                    composer.render();
                    await new Promise(resolve => setTimeout(resolve, 150));
                }

                // è®¡ç®—scaleå€¼
                const scale = typeof preset.scale === 'function' ? preset.scale() : preset.scale;

                // === æ­¥éª¤1ï¼šæ•è·3Dåœºæ™¯ ===
                let canvasDataURL;
                try {
                    canvasDataURL = renderer.domElement.toDataURL('image/png');
                } catch (e) {
                    console.error('Failed to capture 3D scene:', e);
                    throw new Error('æ— æ³•æ•è·3Dåœºæ™¯ï¼Œè¯·æ£€æŸ¥æµè§ˆå™¨å®‰å…¨è®¾ç½®');
                }

                // === æ­¥éª¤2ï¼šåˆ›å»ºåˆæˆcanvas ===
                const finalCanvas = document.createElement('canvas');
                const finalWidth = Math.round(window.innerWidth * scale);
                const finalHeight = Math.round(window.innerHeight * scale);
                finalCanvas.width = finalWidth;
                finalCanvas.height = finalHeight;
                const ctx = finalCanvas.getContext('2d');

                // è®¾ç½®é«˜è´¨é‡æ¸²æŸ“
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';

                // ç»˜åˆ¶èƒŒæ™¯æ¸å˜
                const gradient = ctx.createRadialGradient(
                    finalWidth / 2, finalHeight / 2, 0,
                    finalWidth / 2, finalHeight / 2, finalWidth / 2
                );
                gradient.addColorStop(0, '#0f2027');
                gradient.addColorStop(0.5, '#203a43');
                gradient.addColorStop(1, '#2c5364');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, finalWidth, finalHeight);

                // åŠ è½½å¹¶ç»˜åˆ¶3Dåœºæ™¯
                await new Promise((resolve, reject) => {
                    const img3D = new Image();
                    img3D.onload = () => {
                        ctx.drawImage(img3D, 0, 0, finalWidth, finalHeight);
                        resolve();
                    };
                    img3D.onerror = () => reject(new Error('æ— æ³•åŠ è½½3Dåœºæ™¯å›¾ç‰‡'));
                    img3D.src = canvasDataURL;
                });

                // === æ­¥éª¤3ï¼šæ‰‹åŠ¨ç»˜åˆ¶UIå…ƒç´  ===

                // 3.1 ç»˜åˆ¶èƒŒæ™¯æ ‡é¢˜ "Merry Christmas"
                const titleElement = document.getElementById('background-title');
                if (titleElement && window.getComputedStyle(titleElement).opacity !== '0') {
                    const titleText = titleElement.textContent;
                    const titleFontSize = 110 * scale;
                    const titleOpacity = 0.10;

                    ctx.save();
                    ctx.globalAlpha = titleOpacity;
                    ctx.font = `400 ${titleFontSize}px 'Cinzel', 'Times New Roman', serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    // åˆ›å»ºæ¸å˜æ–‡å­—æ•ˆæœ
                    const textGradient = ctx.createLinearGradient(0, finalHeight/2 - titleFontSize/2, 0, finalHeight/2 + titleFontSize/2);
                    textGradient.addColorStop(0, '#ffffff');
                    textGradient.addColorStop(1, '#eebb66');
                    ctx.fillStyle = textGradient;

                    // æ·»åŠ æ–‡å­—é˜´å½±
                    ctx.shadowColor = 'rgba(252, 238, 167, 0.4)';
                    ctx.shadowBlur = 100 * scale;

                    ctx.fillText(titleText, finalWidth / 2, finalHeight / 2);
                    ctx.restore();
                }

                // 3.2 ç»˜åˆ¶å³ä¸Šè§’æ§åˆ¶æŒ‰é’®
                const controlsWrapper = document.querySelector('.controls-wrapper');
                if (controlsWrapper && !controlsWrapper.classList.contains('ui-hidden')) {
                    const buttonFontSize = 10 * scale;
                    const buttonPadding = 10 * scale;
                    const buttonSpacing = 10 * scale;
                    const btnWidth = 120 * scale;
                    const btnHeight = 40 * scale;

                    let startX = finalWidth - 30 * scale - btnWidth;
                    let startY = 30 * scale;

                    // ç»˜åˆ¶æŒ‰é’®çš„å‡½æ•°
                    const drawButton = (text, x, y) => {
                        ctx.save();

                        // æŒ‰é’®èƒŒæ™¯
                        ctx.fillStyle = 'rgba(20, 20, 20, 0.6)';
                        ctx.fillRect(x, y, btnWidth, btnHeight);

                        // æŒ‰é’®è¾¹æ¡†
                        ctx.strokeStyle = 'rgba(212, 175, 55, 0.4)';
                        ctx.lineWidth = 1 * scale;
                        ctx.strokeRect(x, y, btnWidth, btnHeight);

                        // æŒ‰é’®æ–‡å­—
                        ctx.fillStyle = '#d4af37';
                        ctx.font = `${buttonFontSize}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(text, x + btnWidth/2, y + btnHeight/2);

                        ctx.restore();
                    };

                    // ç¬¬ä¸€è¡ŒæŒ‰é’®
                    drawButton('SELECT FOLDER', startX, startY);
                    drawButton('SELECT FILES', startX + btnWidth + buttonSpacing, startY);

                    // ç¬¬äºŒè¡ŒæŒ‰é’®
                    startY += btnHeight + buttonSpacing;
                    drawButton('SCREENSHOT', startX, startY);
                    drawButton('RECORD', startX + btnWidth + buttonSpacing, startY);
                }

                // 3.3 ç»˜åˆ¶æ‘„åƒå¤´çª—å£
                const webcamWrapper = document.getElementById('webcam-wrapper');
                if (webcamWrapper && !webcamWrapper.classList.contains('ui-hidden')) {
                    const webcamX = 30 * scale;
                    const webcamY = finalHeight - 30 * scale - 210 * scale;
                    const webcamWidth = 280 * scale;
                    const webcamHeight = 210 * scale;

                    ctx.save();

                    // æ‘„åƒå¤´è¾¹æ¡†
                    ctx.strokeStyle = 'rgba(212, 175, 55, 0.5)';
                    ctx.lineWidth = 1 * scale;
                    ctx.strokeRect(webcamX, webcamY, webcamWidth, webcamHeight);

                    // æ‘„åƒå¤´èƒŒæ™¯ï¼ˆé»‘è‰²ï¼‰
                    ctx.fillStyle = '#000';
                    ctx.fillRect(webcamX, webcamY, webcamWidth, webcamHeight);

                    // å°è¯•æ•è·videoå…ƒç´ çš„å½“å‰å¸§
                    const videoElement = document.getElementById('webcam');
                    if (videoElement && videoElement.readyState >= 2) {
                        try {
                            ctx.save();
                            ctx.translate(webcamX + webcamWidth, webcamY);
                            ctx.scale(-1, 1);  // æ°´å¹³ç¿»è½¬
                            ctx.drawImage(videoElement, 0, 0, webcamWidth, webcamHeight);
                            ctx.restore();
                        } catch (e) {
                            console.warn('Cannot capture webcam frame:', e);
                        }
                    }

                    // ç»˜åˆ¶è°ƒè¯•ä¿¡æ¯
                    const debugInfo = document.getElementById('debug-info');
                    if (debugInfo) {
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                        ctx.fillRect(webcamX + 5 * scale, webcamY + webcamHeight - 20 * scale, webcamWidth - 10 * scale, 15 * scale);

                        ctx.fillStyle = 'rgba(212, 175, 55, 0.8)';
                        ctx.font = `${10 * scale}px monospace`;
                        ctx.textAlign = 'left';
                        ctx.fillText(debugInfo.textContent, webcamX + 10 * scale, webcamY + webcamHeight - 10 * scale);
                    }

                    ctx.restore();
                }

                // 3.4 ç»˜åˆ¶FPSè®¡æ•°å™¨
                const fpsCounter = document.getElementById('fps-counter');
                if (fpsCounter) {
                    const fpsText = fpsCounter.textContent;
                    const fpsX = 10 * scale;
                    const fpsY = 10 * scale;

                    ctx.save();

                    // FPSèƒŒæ™¯
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                    ctx.fillRect(fpsX, fpsY, 80 * scale, 25 * scale);

                    // FPSæ–‡å­—
                    ctx.fillStyle = 'rgba(212, 175, 55, 0.8)';
                    ctx.font = `${11 * scale}px monospace`;
                    ctx.textAlign = 'left';
                    ctx.textBaseline = 'top';
                    ctx.fillText(fpsText, fpsX + 10 * scale, fpsY + 7 * scale);

                    ctx.restore();
                }

                // 3.5 ç»˜åˆ¶å½•åˆ¶æŒ‡ç¤ºå™¨ï¼ˆå¦‚æœæ­£åœ¨å½•åˆ¶ï¼‰
                const recordingIndicator = document.getElementById('recording-indicator');
                if (recordingIndicator && recordingIndicator.classList.contains('active')) {
                    const indicatorX = finalWidth - 10 * scale - 100 * scale;
                    const indicatorY = 10 * scale;

                    ctx.save();

                    // èƒŒæ™¯
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                    ctx.fillRect(indicatorX, indicatorY, 100 * scale, 30 * scale);

                    // çº¢ç‚¹
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(indicatorX + 15 * scale, indicatorY + 15 * scale, 5 * scale, 0, Math.PI * 2);
                    ctx.fill();

                    // æ—¶é—´æ–‡å­—
                    const timeText = recordingIndicator.querySelector('.recording-time').textContent;
                    ctx.fillStyle = '#ff0000';
                    ctx.font = `bold ${12 * scale}px monospace`;
                    ctx.textAlign = 'left';
                    ctx.fillText(timeText, indicatorX + 30 * scale, indicatorY + 18 * scale);

                    ctx.restore();
                }

                // æ¢å¤åŸå§‹pixelRatio
                if (preset.rendererPixelRatio) {
                    renderer.setPixelRatio(originalPixelRatio);
                }

                // === æ­¥éª¤4ï¼šå¯¼å‡ºæœ€ç»ˆå›¾ç‰‡ ===
                const finalDataURL = finalCanvas.toDataURL('image/png');

                // åˆ›å»ºä¸‹è½½é“¾æ¥
                const link = document.createElement('a');
                link.download = `ChristmasTree_Screenshot_${quality}_${getTimestamp()}.png`;
                link.href = finalDataURL;
                link.click();

                const sizeKB = Math.round((finalDataURL.length * 3) / 4 / 1024);
                showToast(`æˆªå›¾æˆåŠŸï¼(${finalWidth}Ã—${finalHeight}, ~${sizeKB}KB)`, 'success', 3000);
            } catch (error) {
                console.error('Screenshot failed:', error);
                showToast('æˆªå›¾å¤±è´¥ï¼š' + error.message, 'error', 3000);
            }
        }

        // å¼€å§‹å½•åˆ¶è§†é¢‘ - ä½¿ç”¨å±å¹•æ•è·APIï¼ˆå›ºå®šUltraè´¨é‡ï¼‰
        async function startRecording() {
            try {
                // å›ºå®šä½¿ç”¨Ultraè´¨é‡
                const quality = 'ultra';
                const preset = QUALITY_PRESETS.recording[quality];

                // è®¡ç®—åˆ†è¾¨ç‡
                const width = typeof preset.width === 'function' ? preset.width() : preset.width;
                const height = typeof preset.height === 'function' ? preset.height() : preset.height;

                // ä½¿ç”¨Screen Capture APIè®©ç”¨æˆ·é€‰æ‹©å½•åˆ¶å†…å®¹
                const displayStream = await navigator.mediaDevices.getDisplayMedia({
                    video: {
                        displaySurface: 'browser',  // å»ºè®®å½•åˆ¶æµè§ˆå™¨æ ‡ç­¾é¡µ
                        frameRate: preset.frameRate,
                        width: { ideal: width },
                        height: { ideal: height }
                    },
                    audio: false
                });

                // é€‰æ‹©æ”¯æŒçš„MIMEç±»å‹
                let mimeType = 'video/webm;codecs=vp9';
                if (!MediaRecorder.isTypeSupported(mimeType)) {
                    mimeType = 'video/webm;codecs=vp8';
                    if (!MediaRecorder.isTypeSupported(mimeType)) {
                        mimeType = 'video/webm';
                    }
                }

                // åˆ›å»ºMediaRecorder
                STATE.recording.mediaRecorder = new MediaRecorder(displayStream, {
                    mimeType: mimeType,
                    videoBitsPerSecond: preset.bitrate
                });

                STATE.recording.recordedChunks = [];

                // æ•°æ®å¯ç”¨æ—¶ä¿å­˜
                STATE.recording.mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        STATE.recording.recordedChunks.push(event.data);
                    }
                };

                // åœæ­¢å½•åˆ¶æ—¶ä¿å­˜æ–‡ä»¶
                STATE.recording.mediaRecorder.onstop = () => {
                    const blob = new Blob(STATE.recording.recordedChunks, { type: mimeType });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `ChristmasTree_Video_${quality}_${getTimestamp()}.webm`;
                    link.click();
                    URL.revokeObjectURL(url);

                    const sizeMB = (blob.size / 1024 / 1024).toFixed(2);
                    showToast(`è§†é¢‘å·²ä¿å­˜ï¼(~${sizeMB}MB)`, 'success', 2000);

                    // éšè—å½•åˆ¶æŒ‡ç¤ºå™¨
                    document.getElementById('recording-indicator').classList.remove('active');

                    // åœæ­¢æ‰€æœ‰track
                    displayStream.getTracks().forEach(track => track.stop());
                };

                // ç›‘å¬ç”¨æˆ·åœ¨æµè§ˆå™¨UIä¸­ç‚¹å‡»"åœæ­¢å…±äº«"
                displayStream.getVideoTracks()[0].addEventListener('ended', () => {
                    if (STATE.recording.isRecording) {
                        stopRecording();
                    }
                });

                // å¼€å§‹å½•åˆ¶
                STATE.recording.mediaRecorder.start();
                STATE.recording.isRecording = true;
                STATE.recording.startTime = performance.now();

                // æ˜¾ç¤ºå½•åˆ¶æŒ‡ç¤ºå™¨
                document.getElementById('recording-indicator').classList.add('active');

                // 120ç§’åè‡ªåŠ¨åœæ­¢
                setTimeout(() => {
                    if (STATE.recording.isRecording) {
                        stopRecording();
                        showToast('å·²è¾¾åˆ°æœ€å¤§å½•åˆ¶æ—¶é•¿ï¼ˆ120ç§’ï¼‰', 'warning', 3000);
                    }
                }, STATE.recording.maxDuration);

            } catch (error) {
                console.error('Recording failed:', error);
                if (error.name === 'NotAllowedError') {
                    showToast('å½•åˆ¶å·²å–æ¶ˆ', 'warning', 2000);
                } else {
                    showToast('å½•åˆ¶å¤±è´¥ï¼š' + error.message, 'error', 3000);
                }
                STATE.recording.isRecording = false;
                document.getElementById('recording-indicator').classList.remove('active');
            }
        }

        // åœæ­¢å½•åˆ¶è§†é¢‘
        function stopRecording() {
            if (STATE.recording.mediaRecorder && STATE.recording.isRecording) {
                STATE.recording.mediaRecorder.stop();
                STATE.recording.isRecording = false;
            }
        }

        // æ›´æ–°å½•åˆ¶è®¡æ—¶å™¨
        function updateRecordingTimer() {
            if (STATE.recording.isRecording) {
                const elapsed = Math.floor((performance.now() - STATE.recording.startTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                const timeText = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                document.querySelector('.recording-time').textContent = timeText;
            }
        }

        // ==================== 17. MediaPipeæ‰‹åŠ¿è¯†åˆ«ç³»ç»Ÿ ====================

        // æ‰‹åŠ¿å¹³æ»‘å¤„ç† - ç§»åŠ¨å¹³å‡æ»¤æ³¢
        function smoothHandPosition(x, y) {
            STATE.hand.history.push({ x, y });

            // ä¿ç•™æœ€è¿‘5å¸§
            if (STATE.hand.history.length > 5) {
                STATE.hand.history.shift();
            }

            // è®¡ç®—å¹³å‡å€¼
            const avgX = STATE.hand.history.reduce((sum, p) => sum + p.x, 0) / STATE.hand.history.length;
            const avgY = STATE.hand.history.reduce((sum, p) => sum + p.y, 0) / STATE.hand.history.length;

            return { x: avgX, y: avgY };
        }

        // æ‰‹æŒå¤§å°å¹³æ»‘å¤„ç† - ç”¨äºç¼©æ”¾æ§åˆ¶
        function smoothHandSize(size) {
            STATE.hand.sizeHistory.push(size);

            // ä¿ç•™æœ€è¿‘10å¸§ï¼ˆæ¯”ä½ç½®æ›´å¤šå¸§æ•°ï¼Œè®©ç¼©æ”¾æ›´å¹³æ»‘ï¼‰
            if (STATE.hand.sizeHistory.length > 10) {
                STATE.hand.sizeHistory.shift();
            }

            // è®¡ç®—å¹³å‡å€¼
            const avgSize = STATE.hand.sizeHistory.reduce((sum, s) => sum + s, 0) / STATE.hand.sizeHistory.length;
            return avgSize;
        }

        // æ¨¡å¼åˆ‡æ¢æ§åˆ¶ - å¸¦å†·å´æ—¶é—´é˜²æ­¢é¢‘ç¹åˆ‡æ¢
        function changeMode(newMode) {
            const now = performance.now();

            // æ£€æŸ¥å†·å´æ—¶é—´
            if (now - STATE.lastModeChange < STATE.modeCooldown) {
                return false;
            }

            // åªæœ‰æ¨¡å¼çœŸæ­£æ”¹å˜æ‰æ›´æ–°
            if (STATE.mode !== newMode) {
                STATE.mode = newMode;
                STATE.lastModeChange = now;
                return true;
            }

            return false;
        }

        async function initMediaPipe() {
            video = document.getElementById('webcam');
            
            // Adjust to get best available resolution if possible
            const constraints = {
                video: {
                    width: { ideal: 640 },
                    height: { ideal: 480 },
                    frameRate: { ideal: 30 }
                }
            };

            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
            );
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    // modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                    modelAssetPath: `./hand_landmarker.task`,
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 1
            });
            
            if (navigator.mediaDevices?.getUserMedia) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia(constraints);
                    video.srcObject = stream;
                    video.addEventListener("loadeddata", predictWebcam);
                    debugInfo.innerText = "Webcam active. Show hand.";
                } catch(e) {
                    console.warn("Webcam access denied or not available", e);
                    debugInfo.innerText = "Camera error: " + e.message;
                    document.getElementById('webcam-wrapper').style.display = 'none';
                    showToast('æ‘„åƒå¤´æ— æ³•è®¿é—®ï¼Œæ‰‹åŠ¿æ§åˆ¶å·²ç¦ç”¨', 'warning', 4000);
                }
            }
        }

        let lastVideoTime = -1;
        async function predictWebcam() {
            // æ£€æŸ¥é¡µé¢æ˜¯å¦å¯è§ï¼ˆä¼‘çœ ä¼˜åŒ–ï¼‰
            if (!PERFORMANCE_STATE.isPageVisible) {
                return; // é¡µé¢éšè—æ—¶åœæ­¢æ£€æµ‹å¾ªç¯
            }

            if (video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                if (handLandmarker) {
                    const result = handLandmarker.detectForVideo(video, performance.now());
                    processGestures(result);
                }
            }

            // ä¿å­˜ requestAnimationFrame ID ç”¨äºå–æ¶ˆ
            PERFORMANCE_STATE.mediaPipeFrameId = requestAnimationFrame(predictWebcam);
        }

        // æ‰‹åŠ¿è¯†åˆ«å¤„ç†
        // æ”¯æŒçš„æ‰‹åŠ¿ï¼š
        // - æ¡æ‹³ï¼šåˆ‡æ¢åˆ°TREEæ¨¡å¼
        // - å¼ å¼€ï¼šåˆ‡æ¢åˆ°SCATTERæ¨¡å¼
        // - æåˆï¼šåˆ‡æ¢åˆ°FOCUSæ¨¡å¼
        // - æ‰‹æ‹‰è¿‘/æ¨è¿œï¼šæ§åˆ¶åœºæ™¯ç¼©æ”¾ï¼ˆ0.5x - 2.0xï¼‰
        function processGestures(result) {
            if (result.landmarks && result.landmarks.length > 0) {
                STATE.hand.detected = true;
                const lm = result.landmarks[0];

                // åŸå§‹æ‰‹åŠ¿ä½ç½®
                const rawX = (lm[9].x - 0.5) * 2;
                const rawY = (lm[9].y - 0.5) * 2;

                // åº”ç”¨å¹³æ»‘æ»¤æ³¢
                const smoothed = smoothHandPosition(rawX, rawY);
                STATE.hand.x = smoothed.x;
                STATE.hand.y = smoothed.y;

                const thumb = lm[4]; 
                const index = lm[8]; 
                const wrist = lm[0];
                const middleMCP = lm[9]; // ä¸­æŒ‡æŒ‡æ ¹ (Knuckle)

                // 1. è®¡ç®—æ‰‹æŒåŸºå‡†å¤§å° (æ‰‹è…•åˆ°ä¸­æŒ‡æŒ‡æ ¹çš„è·ç¦»)
                const handSize = Math.hypot(middleMCP.x - wrist.x, middleMCP.y - wrist.y);
                if (handSize < 0.02) return;

                // 2. æ‰‹æŒå¤§å°å¹³æ»‘å¤„ç†
                const smoothedHandSize = smoothHandSize(handSize);

                // 3. ç¼©æ”¾æ§åˆ¶ï¼šåˆå§‹åŒ–åŸºå‡†æ‰‹æŒå¤§å°
                if (STATE.baseHandSize === 0) {
                    STATE.baseHandSize = smoothedHandSize;
                }

                // 4. æ ¹æ®æ‰‹æŒå¤§å°å˜åŒ–è®¡ç®—ç¼©æ”¾æ¯”ä¾‹
                // æ‰‹æ‹‰è¿‘ï¼ˆæ‰‹æŒå˜å¤§ï¼‰â†’ åœºæ™¯æ”¾å¤§ï¼Œæ‰‹æ¨è¿œï¼ˆæ‰‹æŒå˜å°ï¼‰â†’ åœºæ™¯ç¼©å°
                const sizeRatio = smoothedHandSize / STATE.baseHandSize;
                // é™åˆ¶ç¼©æ”¾èŒƒå›´ 0.5x - 2.0x
                STATE.targetZoom = Math.max(0.5, Math.min(2.0, sizeRatio));

                // 5. è®¡ç®—æ‰‹æŒ‡å°–ç«¯çš„å¹³å‡ä¼¸å±•è·ç¦»
                const tips = [lm[8], lm[12], lm[16], lm[20]];
                let avgTipDist = 0;
                tips.forEach(t => avgTipDist += Math.hypot(t.x - wrist.x, t.y - wrist.y));
                avgTipDist /= 4;

                // 6. è®¡ç®—æåˆè·ç¦» (æ‹‡æŒ‡åˆ°é£ŸæŒ‡)
                const pinchDist = Math.hypot(thumb.x - index.x, thumb.y - index.y);

                // 7. è®¡ç®—ç›¸å¯¹æ¯”ä¾‹
                const extensionRatio = avgTipDist / handSize;
                const pinchRatio = pinchDist / handSize;

                // è°ƒè¯•æ˜¾ç¤º
                debugInfo.innerText = `Size: ${handSize.toFixed(2)} | Zoom: ${STATE.targetZoom.toFixed(2)}x | Ext: ${extensionRatio.toFixed(2)} | Pinch: ${pinchRatio.toFixed(2)} | Mode: ${STATE.mode}`;

                // 8. çŠ¶æ€åˆ¤å®šä¼˜åŒ– + å†·å´æ§åˆ¶
                // ä¼˜å…ˆæ£€æŸ¥æ¡æ‹³ (Tree)ï¼Œé˜²æ­¢å› ä¸ºå¤§æ‹‡æŒ‡é è¿‘é£ŸæŒ‡è€Œè¢«è¯¯åˆ¤ä¸º Focus
                if (extensionRatio < 1.5) {
                    // æ¡æ‹³ï¼šå˜æˆæ ‘
                    if (changeMode('TREE')) {
                        STATE.focusTarget = null;
                    }
                } else if (pinchRatio < 0.35) {
                    // æåˆï¼šè¿›å…¥èšç„¦æ¨¡å¼ (ä»…å½“æ²¡æœ‰æ¡æ‹³æ—¶æ‰æ£€æŸ¥)
                    if (changeMode('FOCUS')) {
                        const photos = particleSystem.filter(p => p.type === 'PHOTO');
                        if (photos.length) {
                            STATE.focusTarget = photos[Math.floor(Math.random() * photos.length)].mesh;
                        }
                    }
                } else if (extensionRatio > 1.7) {
                    // å¼ å¼€ï¼šæ•£å¼€ç…§ç‰‡
                    if (changeMode('SCATTER')) {
                        STATE.focusTarget = null;
                    }
                }
            } else {
                STATE.hand.detected = false;
                debugInfo.innerText = "No hand detected";

                // æ‰‹ç¦»å¼€æ—¶é‡ç½®åŸºå‡†ï¼Œä¸‹æ¬¡æ£€æµ‹åˆ°æ‰‹æ—¶é‡æ–°å»ºç«‹åŸºå‡†
                if (STATE.baseHandSize !== 0) {
                    STATE.baseHandSize = 0;
                    STATE.hand.sizeHistory = [];
                }
            }
        }

        // ==================== 18. äº‹ä»¶ç›‘å¬è®¾ç½® ====================
        function setupEvents() {
            // çª—å£å¤§å°è°ƒæ•´
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
            });

            // é¡µé¢å¯è§æ€§å˜åŒ–ç›‘å¬ï¼ˆæ€§èƒ½ä¼‘çœ ä¼˜åŒ–ï¼‰
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    pauseApp();  // é¡µé¢å¤±ç„¦ï¼Œè¿›å…¥ä¼‘çœ 
                } else {
                    resumeApp(); // é¡µé¢æ¢å¤ï¼Œå”¤é†’åº”ç”¨
                }
            });

            // æ–‡ä»¶ä¸Šä¼ 
            document.getElementById('file-input').addEventListener('change', handleImageUpload);
            document.getElementById('folder-input').addEventListener('change', handleImageUpload);

            // ========== éŸ³ä¹æ§åˆ¶ ==========
            // æ’­æ”¾/æš‚åœæŒ‰é’®
            const playPauseBtn = document.getElementById('play-pause-btn');
            if (playPauseBtn) {
                playPauseBtn.addEventListener('click', togglePlayPause);
            }

            // é™éŸ³æŒ‰é’®
            const muteBtn = document.getElementById('mute-btn');
            if (muteBtn) {
                muteBtn.addEventListener('click', toggleMute);
            }

            // éŸ³é‡æ»‘å—
            const volumeSlider = document.getElementById('volume-slider');
            if (volumeSlider) {
                volumeSlider.addEventListener('input', (e) => {
                    const volume = parseFloat(e.target.value) / 100;
                    setVolume(volume);

                    // å¦‚æœé™éŸ³çŠ¶æ€ä¸‹è°ƒæ•´éŸ³é‡ï¼Œè‡ªåŠ¨å–æ¶ˆé™éŸ³
                    if (STATE.music.isMuted && volume > 0) {
                        STATE.music.isMuted = false;
                        updateMuteButton();
                    }
                });
            }

            // è‡ªåŠ¨æ’­æ”¾æç¤ºæŒ‰é’®
            const startMusicBtn = document.getElementById('start-music-btn');
            if (startMusicBtn) {
                startMusicBtn.addEventListener('click', startMusic);
            }

            // ========== é”®ç›˜æ§åˆ¶ ==========
            window.addEventListener('keydown', (e) => {
                // Hé”®ï¼šéšè—æ‰€æœ‰UIï¼ˆåŒ…æ‹¬æ‘„åƒå¤´å’ŒéŸ³ä¹æ§åˆ¶ï¼‰
                if (e.key.toLowerCase() === 'h') {
                    const controls = document.querySelector('.controls-wrapper');
                    if (controls) controls.classList.toggle('ui-hidden');
                    const webcam = document.getElementById('webcam-wrapper');
                    if(webcam) webcam.classList.toggle('ui-hidden');
                    const musicControls = document.getElementById('music-controls');
                    if(musicControls) musicControls.classList.toggle('ui-hidden');
                }

                // Cé”®ï¼šå•ç‹¬éšè—/æ˜¾ç¤ºæ‘„åƒå¤´
                if (e.key.toLowerCase() === 'c') {
                    const webcam = document.getElementById('webcam-wrapper');
                    if(webcam) webcam.classList.toggle('ui-hidden');
                }

                // Mé”®ï¼šæ’­æ”¾/æš‚åœéŸ³ä¹
                if (e.key.toLowerCase() === 'm') {
                    e.preventDefault();
                    togglePlayPause();
                }

                // Né”®ï¼šé™éŸ³/å–æ¶ˆé™éŸ³
                if (e.key.toLowerCase() === 'n') {
                    e.preventDefault();
                    toggleMute();
                }

                // 1/2/3é”®ï¼šå¼ºåˆ¶åˆ‡æ¢æ¨¡å¼
                if (e.key === '1') {
                    STATE.mode = 'TREE';
                    STATE.focusTarget = null;
                }
                if (e.key === '2') {
                    STATE.mode = 'SCATTER';
                    STATE.focusTarget = null;
                }
                if (e.key === '3') {
                    const photos = particleSystem.filter(p => p.type === 'PHOTO');
                    if (photos.length) {
                        STATE.mode = 'FOCUS';
                        STATE.focusTarget = photos[Math.floor(Math.random() * photos.length)].mesh;
                    }
                }

                // ESCé”®ï¼šä»FOCUSé€€å‡ºåˆ°SCATTER
                if (e.key === 'Escape') {
                    if (STATE.mode === 'FOCUS') {
                        STATE.mode = 'SCATTER';
                        STATE.focusTarget = null;
                    }
                }

                // ç©ºæ ¼é”®ï¼šé‡ç½®æ‰€æœ‰
                if (e.key === ' ') {
                    e.preventDefault();
                    STATE.targetZoom = 1.0;
                    STATE.rotation.x = 0;
                    STATE.rotation.y = 0;
                    STATE.camera.targetPosition.x = 0;
                    STATE.camera.targetPosition.y = 0;
                    STATE.camera.targetPosition.z = 50;
                    STATE.mouse.manualControl = false;
                }

                // Pé”®ï¼šæˆªå›¾
                if (e.key.toLowerCase() === 'p') {
                    e.preventDefault();
                    takeScreenshot();
                }

                // Vé”®ï¼šå½•åˆ¶/åœæ­¢
                if (e.key.toLowerCase() === 'v') {
                    e.preventDefault();
                    if (STATE.recording.isRecording) {
                        stopRecording();
                    } else {
                        startRecording();
                    }
                }
            });

            // ========== é¼ æ ‡æ»šè½®ï¼šç¼©æ”¾ ==========
            window.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? 0.95 : 1.05;
                STATE.targetZoom = Math.max(0.5, Math.min(2.0, STATE.targetZoom * delta));
            }, { passive: false });

            // ========== é¼ æ ‡æ‹–æ‹½ï¼šæ—‹è½¬å’Œå¹³ç§» ==========
            window.addEventListener('mousedown', (e) => {
                if (e.button === 0) {
                    // å·¦é”®
                    STATE.mouse.isDragging = true;
                } else if (e.button === 2) {
                    // å³é”®ï¼šå¹³ç§»
                    STATE.mouse.isRightDragging = true;
                }
                STATE.mouse.lastX = e.clientX;
                STATE.mouse.lastY = e.clientY;
                STATE.mouse.dragStartTime = performance.now();
            });

            window.addEventListener('mousemove', (e) => {
                if (STATE.mouse.isDragging) {
                    // å·¦é”®æ‹–æ‹½ï¼šæ—‹è½¬åœºæ™¯
                    const deltaX = e.clientX - STATE.mouse.lastX;
                    const deltaY = e.clientY - STATE.mouse.lastY;

                    STATE.rotation.y += deltaX * 0.005;
                    STATE.rotation.x += deltaY * 0.005;

                    // æ ‡è®°ä¸ºæ‰‹åŠ¨æ§åˆ¶ï¼ˆåœæ­¢è‡ªåŠ¨æ—‹è½¬ï¼‰
                    STATE.mouse.manualControl = true;
                    STATE.mouse.lastManualTime = performance.now();

                } else if (STATE.mouse.isRightDragging) {
                    // å³é”®æ‹–æ‹½ï¼šå¹³ç§»ç›¸æœº
                    const deltaX = e.clientX - STATE.mouse.lastX;
                    const deltaY = e.clientY - STATE.mouse.lastY;

                    STATE.camera.targetPosition.x -= deltaX * 0.05;
                    STATE.camera.targetPosition.y += deltaY * 0.05;
                }

                STATE.mouse.lastX = e.clientX;
                STATE.mouse.lastY = e.clientY;
            });

            window.addEventListener('mouseup', (e) => {
                // æ£€æŸ¥æ˜¯å¦æ˜¯ç‚¹å‡»ï¼ˆè€Œä¸æ˜¯æ‹–æ‹½ï¼‰
                const clickTime = performance.now() - STATE.mouse.dragStartTime;
                const isClick = clickTime < 200;  // å°äº200msè®¤ä¸ºæ˜¯ç‚¹å‡»

                if (e.button === 0) {
                    if (isClick) {
                        // æ˜¯ç‚¹å‡»ï¼Œå¤„ç†ç‚¹å‡»äº‹ä»¶
                        handleMouseClick(e);
                    } else {
                        // æ˜¯æ‹–æ‹½ï¼Œ1ç§’åæ¢å¤è‡ªåŠ¨æ—‹è½¬
                        setTimeout(() => {
                            if (performance.now() - STATE.mouse.lastManualTime > 1000) {
                                STATE.mouse.manualControl = false;
                            }
                        }, 1000);
                    }
                }

                STATE.mouse.isDragging = false;
                STATE.mouse.isRightDragging = false;
            });

            // ç¦ç”¨å³é”®èœå•
            window.addEventListener('contextmenu', (e) => e.preventDefault());

            // ========== æˆªå›¾å’Œå½•åˆ¶æŒ‰é’® ==========
            document.getElementById('screenshot-btn').addEventListener('click', () => {
                takeScreenshot();
            });

            document.getElementById('record-btn').addEventListener('click', () => {
                if (STATE.recording.isRecording) {
                    stopRecording();
                } else {
                    startRecording();
                }
            });
        }

        // ========== é¼ æ ‡ç‚¹å‡»å¤„ç† ==========
        function handleMouseClick(e) {
            // å°†é¼ æ ‡ä½ç½®è½¬æ¢ä¸ºå½’ä¸€åŒ–è®¾å¤‡åæ ‡ (-1 to +1)
            mouseVector.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouseVector.y = -(e.clientY / window.innerHeight) * 2 + 1;

            // ä½¿ç”¨raycasteræ£€æµ‹ç‚¹å‡»çš„ç‰©ä½“
            raycaster.setFromCamera(mouseVector, camera);

            // è·å–æ‰€æœ‰ç…§ç‰‡mesh
            const photos = particleSystem.filter(p => p.type === 'PHOTO');
            const photoMeshes = photos.map(p => p.mesh);

            // æ£€æµ‹ç›¸äº¤çš„ç‰©ä½“ï¼ˆéœ€è¦é€’å½’æ£€æµ‹Groupçš„å­å…ƒç´ ï¼‰
            const intersects = raycaster.intersectObjects(photoMeshes, true);

            if (intersects.length > 0) {
                // ç‚¹å‡»åˆ°ç…§ç‰‡
                const clickedMesh = intersects[0].object.parent;  // è·å–ç…§ç‰‡çš„Group

                if (STATE.mode === 'TREE') {
                    // TREEæ¨¡å¼ï¼šç‚¹å‡»ç…§ç‰‡è¿›å…¥SCATTER
                    STATE.mode = 'SCATTER';

                } else if (STATE.mode === 'SCATTER' || STATE.mode === 'FOCUS') {
                    // SCATTER/FOCUSæ¨¡å¼ï¼šèšç„¦ç‚¹å‡»çš„ç…§ç‰‡
                    STATE.mode = 'FOCUS';
                    STATE.focusTarget = clickedMesh;
                }
            } else {
                // ç‚¹å‡»ç©ºç™½å¤„
                if (STATE.mode === 'FOCUS') {
                    // FOCUS â†’ SCATTER
                    STATE.mode = 'SCATTER';
                    STATE.focusTarget = null;

                } else if (STATE.mode === 'TREE') {
                    // TREE â†’ SCATTER
                    STATE.mode = 'SCATTER';

                } else if (STATE.mode === 'SCATTER') {
                    // SCATTER â†’ TREE
                    STATE.mode = 'TREE';
                    STATE.focusTarget = null;
                }
            }
        }

        // ==================== 17. æ€§èƒ½ç›‘æ§ç³»ç»Ÿ ====================
        // FPSç›‘æ§å’Œè‡ªåŠ¨æ€§èƒ½é™çº§
        function updateFPS() {
            fpsMonitor.frames++;
            const now = performance.now();
            const delta = now - fpsMonitor.lastTime;

            if (delta >= 1000) {
                fpsMonitor.fps = Math.round((fpsMonitor.frames * 1000) / delta);
                fpsMonitor.frames = 0;
                fpsMonitor.lastTime = now;

                if (fpsMonitor.counter) {
                    fpsMonitor.counter.innerText = `FPS: ${fpsMonitor.fps}`;

                    // æ€§èƒ½è‡ªåŠ¨é™çº§
                    if (CONFIG.performance.autoScale && fpsMonitor.fps < CONFIG.performance.minFPS) {
                        if (CONFIG.particles.dustCount > 500) {
                            CONFIG.particles.dustCount = Math.floor(CONFIG.particles.dustCount * 0.8);
                            console.warn(`Performance degradation detected. Reducing dust particles to ${CONFIG.particles.dustCount}`);
                        }
                    }
                }
            }
        }

        // ==================== 19. åŠ¨ç”»å¾ªç¯ ====================
        function animate() {
            // æ£€æŸ¥é¡µé¢æ˜¯å¦å¯è§ï¼ˆä¼‘çœ ä¼˜åŒ–ï¼‰
            if (!PERFORMANCE_STATE.isPageVisible) {
                return; // é¡µé¢éšè—æ—¶åœæ­¢å¾ªç¯ï¼Œä¸å†è°ƒç”¨ requestAnimationFrame
            }

            // ä¿å­˜ requestAnimationFrame ID ç”¨äºå–æ¶ˆ
            PERFORMANCE_STATE.animationFrameId = requestAnimationFrame(animate);
            const dt = clock.getDelta();

            // æ›´æ–°FPSç›‘æ§
            updateFPS();

            // ç¼©æ”¾æ§åˆ¶é€»è¾‘ - å¹³æ»‘æ’å€¼
            STATE.zoom += (STATE.targetZoom - STATE.zoom) * 5.0 * dt;
            mainGroup.scale.set(STATE.zoom, STATE.zoom, STATE.zoom);

            // ç›¸æœºä½ç½®å¹³æ»‘æ’å€¼ï¼ˆå³é”®æ‹–æ‹½å¹³ç§»ï¼‰
            STATE.camera.position.x += (STATE.camera.targetPosition.x - STATE.camera.position.x) * 5.0 * dt;
            STATE.camera.position.y += (STATE.camera.targetPosition.y - STATE.camera.position.y) * 5.0 * dt;
            STATE.camera.position.z += (STATE.camera.targetPosition.z - STATE.camera.position.z) * 5.0 * dt;
            camera.position.set(STATE.camera.position.x, STATE.camera.position.y, STATE.camera.position.z);

            // æ—‹è½¬æ§åˆ¶é€»è¾‘
            if (STATE.mode === 'SCATTER' && STATE.hand.detected) {
                // æ‰‹åŠ¿æ§åˆ¶æ—‹è½¬
                const targetRotY = STATE.hand.x * Math.PI * 0.9;
                const targetRotX = STATE.hand.y * Math.PI * 0.25;
                STATE.rotation.y += (targetRotY - STATE.rotation.y) * 3.0 * dt;
                STATE.rotation.x += (targetRotX - STATE.rotation.x) * 3.0 * dt;
            } else if (!STATE.mouse.manualControl) {
                // è‡ªåŠ¨æ—‹è½¬ï¼ˆå½“æ²¡æœ‰æ‰‹åŠ¨æ§åˆ¶æ—¶ï¼‰
                if(STATE.mode === 'TREE') {
                    STATE.rotation.y += 0.3 * dt;
                    STATE.rotation.x += (0 - STATE.rotation.x) * 2.0 * dt;
                } else {
                      STATE.rotation.y += 0.1 * dt;
                }
            }
            // å¦‚æœæ­£åœ¨æ‰‹åŠ¨æ§åˆ¶ï¼ˆé¼ æ ‡æ‹–æ‹½ï¼‰ï¼Œåˆ™ä¿æŒå½“å‰æ—‹è½¬è§’åº¦ä¸å˜

            mainGroup.rotation.y = STATE.rotation.y;
            mainGroup.rotation.x = STATE.rotation.x;

            particleSystem.forEach(p => p.update(dt, STATE.mode, STATE.focusTarget));

            // æ›´æ–°é›ªèŠ±
            updateSnow(dt);

            // æ›´æ–°å½•åˆ¶è®¡æ—¶å™¨
            updateRecordingTimer();

            composer.render();
        }

        // ==================== 20. å¯åŠ¨åº”ç”¨ ====================
        init();

    </script>
</body>
</html>